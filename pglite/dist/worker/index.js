import{c as $}from"../chunk-WV37ZJ3Z.js";import{d as s,e as d,f as p,g as h,i as S}from"../chunk-TTNLE7CV.js";S();var L,T,O,b,C,w,R,E,m,I,A,G,M,k,D,f,W,N,B,o,F,q,g,z,j=class j{constructor(e,t){d(this,o);d(this,L);d(this,T,0);d(this,O,!1);d(this,b,!1);d(this,C,!1);d(this,w,new EventTarget);d(this,R);d(this,E,!1);d(this,m);d(this,I);d(this,A);d(this,G);d(this,M);d(this,k);d(this,D);d(this,f,new Map);d(this,W,new Set);d(this,N);d(this,B,[]);p(this,m,e),p(this,R,$()),p(this,N,t?.extensions??{}),p(this,A,new Promise(r=>{s(this,m).addEventListener("message",a=>{if(a.data.type==="here")r();else throw new Error("Invalid message")},{once:!0})})),p(this,G,new Promise(r=>{let a=i=>{i.data.type==="ready"&&(p(this,I,i.data.id),s(this,m).removeEventListener("message",a),r())};s(this,m).addEventListener("message",a)})),p(this,L,h(this,o,F).call(this,t))}static async create(e,t){let r=new j(e,t);return await s(r,L),r}get waitReady(){return new Promise(e=>{s(this,L).then(()=>{s(this,E)?e():e(new Promise(t=>{s(this,w).addEventListener("connected",()=>{t()})}))})})}get debug(){return s(this,T)}get ready(){return s(this,O)}get closed(){return s(this,b)}get isLeader(){return s(this,C)}async close(){var e;s(this,b)||(p(this,b,!0),s(this,M)?.close(),s(this,k)?.close(),(e=s(this,D))==null||e.call(this),s(this,m).terminate())}async[Symbol.asyncDispose](){await this.close()}async query(e,t,r){return await this.waitReady,await h(this,o,g).call(this,"query",e,t,r)}async exec(e,t){return await this.waitReady,await h(this,o,g).call(this,"exec",e,t)}async transaction(e){await this.waitReady;let t=await h(this,o,g).call(this,"transactionStart"),r;try{r=await e({query:async(a,i,y)=>await h(this,o,g).call(this,"transactionQuery",t,a,i,y),exec:async(a,i)=>await h(this,o,g).call(this,"transactionExec",t,a,i),rollback:async()=>{await h(this,o,g).call(this,"transactionRollback",t)},closed:!1})}catch(a){throw await h(this,o,g).call(this,"transactionRollback",t),a}return await h(this,o,g).call(this,"transactionCommit",t),r}async execProtocolRaw(e){return await this.waitReady,await h(this,o,g).call(this,"execProtocolRaw",e)}async execProtocol(e){return await this.waitReady,await h(this,o,g).call(this,"execProtocol",e)}async listen(e,t){return await this.waitReady,s(this,f).has(e)||s(this,f).set(e,new Set),s(this,f).get(e)?.add(t),await this.exec(`LISTEN ${e}`),async()=>{await this.unlisten(e,t)}}async unlisten(e,t){await this.waitReady,t?s(this,f).get(e)?.delete(t):s(this,f).delete(e),s(this,f).get(e)?.size===0&&await this.exec(`UNLISTEN ${e}`)}onNotification(e){return s(this,W).add(e),()=>{s(this,W).delete(e)}}offNotification(e){s(this,W).delete(e)}async dumpDataDir(){return await h(this,o,g).call(this,"dumpDataDir")}onLeaderChange(e){return s(this,w).addEventListener("leader-change",e),()=>{s(this,w).removeEventListener("leader-change",e)}}offLeaderChange(e){s(this,w).removeEventListener("leader-change",e)}};L=new WeakMap,T=new WeakMap,O=new WeakMap,b=new WeakMap,C=new WeakMap,w=new WeakMap,R=new WeakMap,E=new WeakMap,m=new WeakMap,I=new WeakMap,A=new WeakMap,G=new WeakMap,M=new WeakMap,k=new WeakMap,D=new WeakMap,f=new WeakMap,W=new WeakMap,N=new WeakMap,B=new WeakMap,o=new WeakSet,F=async function(e={}){for(let[n,v]of Object.entries(s(this,N))){if(v instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let l=await v.setup(this,{},!0);if(l.emscriptenOpts&&console.warn(`PGlite extension ${n} returned emscriptenOpts, these are not supported on the client side of a worker`),l.namespaceObj){let u=this;u[n]=l.namespaceObj}l.bundlePath&&console.warn(`PGlite extension ${n} returned bundlePath, this is not supported on the client side of a worker`),l.init&&await l.init(),l.close&&s(this,B).push(l.close)}}await s(this,A);let{extensions:t,...r}=e;s(this,m).postMessage({type:"init",options:r}),await s(this,G);let a=`pglite-tab-close:${s(this,R)}`;p(this,D,await H(a));let i=`pglite-broadcast:${s(this,I)}`;p(this,M,new BroadcastChannel(i));let y=`pglite-tab:${s(this,R)}`;p(this,k,new BroadcastChannel(y)),s(this,M).addEventListener("message",async n=>{n.data.type==="leader-here"?(p(this,E,!1),s(this,w).dispatchEvent(new Event("leader-change")),h(this,o,q).call(this)):n.data.type==="notify"&&h(this,o,z).call(this,n.data.channel,n.data.payload)}),s(this,k).addEventListener("message",async n=>{n.data.type==="connected"&&(p(this,E,!0),s(this,w).dispatchEvent(new Event("connected")),p(this,T,await h(this,o,g).call(this,"getDebugLevel")),p(this,O,!0))}),s(this,m).addEventListener("message",async n=>{n.data.type==="leader-now"&&(p(this,C,!0),s(this,w).dispatchEvent(new Event("leader-change")))}),h(this,o,q).call(this)},q=async function(){s(this,E)||(s(this,M).postMessage({type:"tab-here",id:s(this,R)}),setTimeout(()=>h(this,o,q).call(this),16))},g=async function(e,...t){let r=$(),a={type:"rpc-call",callId:r,method:e,args:t};return s(this,k).postMessage(a),await new Promise((i,y)=>{let n=u=>{if(u.data.callId!==r)return;l();let P=u.data;if(P.type==="rpc-return")i(P.result);else if(P.type==="rpc-error"){let x=new Error(P.error.message);Object.assign(x,P.error),y(x)}else y(new Error("Invalid message"))},v=()=>{l(),y(new U)},l=()=>{s(this,k).removeEventListener("message",n),s(this,w).removeEventListener("leader-change",v)};s(this,w).addEventListener("leader-change",v),s(this,k).addEventListener("message",n)})},z=function(e,t){let r=s(this,f).get(e);if(r)for(let a of r)queueMicrotask(()=>a(t));for(let a of s(this,W))queueMicrotask(()=>a(e,t))};var Q=j;async function _({init:c}){postMessage({type:"here"});let e=await new Promise(l=>{addEventListener("message",u=>{u.data.type==="init"&&l(u.data.options)},{once:!0})}),t=e.id??`${import.meta.url}:${e.dataDir??""}`;postMessage({type:"ready",id:t});let r=`pglite-election-lock:${t}`,a=`pglite-broadcast:${t}`,i=new BroadcastChannel(a),y=new Set;await H(r);let n=c(e);i.onmessage=async l=>{let u=l.data;switch(u.type){case"tab-here":J(u.id,await n,y);break}},i.postMessage({type:"leader-here",id:t}),postMessage({type:"leader-now"}),(await n).onNotification((l,u)=>{i.postMessage({type:"notify",channel:l,payload:u})})}function J(c,e,t){if(t.has(c))return;t.add(c);let r=`pglite-tab:${c}`,a=`pglite-tab-close:${c}`,i=new BroadcastChannel(r);navigator.locks.request(a,()=>new Promise(n=>{i.close(),t.delete(c),n()}));let y=K(e);i.addEventListener("message",async n=>{let v=n.data;switch(v.type){case"rpc-call":{let{callId:l,method:u,args:P}=v;try{let x=await y[u](...P);i.postMessage({type:"rpc-return",callId:l,result:x})}catch(x){console.error(x),i.postMessage({type:"rpc-error",callId:l,error:{message:x.message}})}break}}}),i.postMessage({type:"connected"})}function K(c){let e=new Map;return{async getDebugLevel(){return c.debug},async close(){await c.close()},async query(t,r,a){return await c.query(t,r,a)},async exec(t,r){return await c.exec(t,r)},async transactionStart(){let t=$(),{promise:r,resolve:a}=V();return e.set(t,r),c.transaction(i=>new Promise((y,n)=>{a({tx:i,resolve:y,reject:n})})),t},async transactionCommit(t){if(!e.has(t))throw new Error("No transaction");(await e.get(t)).resolve(),e.delete(t)},async transactionQuery(t,r,a,i){if(!e.has(t))throw new Error("No transaction");return await(await e.get(t)).tx.query(r,a,i)},async transactionExec(t,r,a){if(!e.has(t))throw new Error("No transaction");return(await e.get(t)).tx.exec(r,a)},async transactionRollback(t){if(!e.has(t))throw new Error("No transaction");let r=await e.get(t);await r.tx.rollback(),r.reject(new Error("Transaction rolled back")),e.delete(t)},async execProtocol(t){return await c.execProtocol(t)},async execProtocolRaw(t){return await c.execProtocolRaw(t)},async dumpDataDir(){return await c.dumpDataDir()}}}var U=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function H(c){let e;return await new Promise(t=>{navigator.locks.request(c,()=>new Promise(r=>{e=r,t()}))}),e}function V(){let c,e;return{promise:new Promise((r,a)=>{c=r,e=a}),resolve:c,reject:e}}export{U as LeaderChangedError,Q as PGliteWorker,_ as worker};
//# sourceMappingURL=index.js.map