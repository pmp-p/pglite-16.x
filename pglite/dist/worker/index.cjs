"use strict";var N=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var X=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var V=r=>{throw TypeError(r)};var Z=(r,e)=>{for(var t in e)N(r,t,{get:e[t],enumerable:!0})},ee=(r,e,t,a)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of X(e))!Y.call(r,n)&&n!==t&&N(r,n,{get:()=>e[n],enumerable:!(a=K(e,n))||a.enumerable});return r};var te=r=>ee(N({},"__esModule",{value:!0}),r);var B=(r,e,t)=>e.has(r)||V("Cannot "+t);var s=(r,e,t)=>(B(r,e,"read from private field"),t?t.call(r):e.get(r)),l=(r,e,t)=>e.has(r)?V("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),h=(r,e,t,a)=>(B(r,e,"write to private field"),a?a.call(r,t):e.set(r,t),t),p=(r,e,t)=>(B(r,e,"access private method"),t);var oe={};Z(oe,{LeaderChangedError:()=>$,PGliteWorker:()=>_,worker:()=>se});module.exports=te(oe);var re=()=>typeof document>"u"?new URL(`file:${__filename}`).href:document.currentScript&&document.currentScript.src||new URL("main.js",document.baseURI).href,Q=re();var de=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var D=()=>{if(globalThis.crypto?.randomUUID)return globalThis.crypto.randomUUID();let r=new Uint8Array(16);if(globalThis.crypto?.getRandomValues)globalThis.crypto.getRandomValues(r);else for(let t=0;t<r.length;t++)r[t]=Math.floor(Math.random()*256);r[6]=r[6]&15|64,r[8]=r[8]&63|128;let e=[];return r.forEach(t=>{e.push(t.toString(16).padStart(2,"0"))}),e.slice(0,4).join("")+"-"+e.slice(4,6).join("")+"-"+e.slice(6,8).join("")+"-"+e.slice(8,10).join("")+"-"+e.slice(10).join("")};var T,W,A,M,I,w,R,E,m,O,C,U,L,P,G,f,b,j,q,c,H,S,g,z,F=class F{constructor(e,t){l(this,c);l(this,T);l(this,W,0);l(this,A,!1);l(this,M,!1);l(this,I,!1);l(this,w,new EventTarget);l(this,R);l(this,E,!1);l(this,m);l(this,O);l(this,C);l(this,U);l(this,L);l(this,P);l(this,G);l(this,f,new Map);l(this,b,new Set);l(this,j);l(this,q,[]);h(this,m,e),h(this,R,D()),h(this,j,t?.extensions??{}),h(this,C,new Promise(a=>{s(this,m).addEventListener("message",n=>{if(n.data.type==="here")a();else throw new Error("Invalid message")},{once:!0})})),h(this,U,new Promise(a=>{let n=i=>{i.data.type==="ready"&&(h(this,O,i.data.id),s(this,m).removeEventListener("message",n),a())};s(this,m).addEventListener("message",n)})),h(this,T,p(this,c,H).call(this,t))}static async create(e,t){let a=new F(e,t);return await s(a,T),a}get waitReady(){return new Promise(e=>{s(this,T).then(()=>{s(this,E)?e():e(new Promise(t=>{s(this,w).addEventListener("connected",()=>{t()})}))})})}get debug(){return s(this,W)}get ready(){return s(this,A)}get closed(){return s(this,M)}get isLeader(){return s(this,I)}async close(){var e;s(this,M)||(h(this,M,!0),s(this,L)?.close(),s(this,P)?.close(),(e=s(this,G))==null||e.call(this),s(this,m).terminate())}async[Symbol.asyncDispose](){await this.close()}async query(e,t,a){return await this.waitReady,await p(this,c,g).call(this,"query",e,t,a)}async sql(e,...t){return await this.waitReady,await p(this,c,g).call(this,"sql",e,e.raw,t)}async exec(e,t){return await this.waitReady,await p(this,c,g).call(this,"exec",e,t)}async transaction(e){await this.waitReady;let t=await p(this,c,g).call(this,"transactionStart"),a;try{a=await e({query:async(n,i,y)=>await p(this,c,g).call(this,"transactionQuery",t,n,i,y),exec:async(n,i)=>await p(this,c,g).call(this,"transactionExec",t,n,i),rollback:async()=>{await p(this,c,g).call(this,"transactionRollback",t)},closed:!1})}catch(n){throw await p(this,c,g).call(this,"transactionRollback",t),n}return await p(this,c,g).call(this,"transactionCommit",t),a}async execProtocolRaw(e){return await this.waitReady,await p(this,c,g).call(this,"execProtocolRaw",e)}async execProtocol(e){return await this.waitReady,await p(this,c,g).call(this,"execProtocol",e)}async listen(e,t){return await this.waitReady,s(this,f).has(e)||s(this,f).set(e,new Set),s(this,f).get(e)?.add(t),await this.exec(`LISTEN ${e}`),async()=>{await this.unlisten(e,t)}}async unlisten(e,t){await this.waitReady,t?s(this,f).get(e)?.delete(t):s(this,f).delete(e),s(this,f).get(e)?.size===0&&await this.exec(`UNLISTEN ${e}`)}onNotification(e){return s(this,b).add(e),()=>{s(this,b).delete(e)}}offNotification(e){s(this,b).delete(e)}async dumpDataDir(){return await p(this,c,g).call(this,"dumpDataDir")}onLeaderChange(e){return s(this,w).addEventListener("leader-change",e),()=>{s(this,w).removeEventListener("leader-change",e)}}offLeaderChange(e){s(this,w).removeEventListener("leader-change",e)}};T=new WeakMap,W=new WeakMap,A=new WeakMap,M=new WeakMap,I=new WeakMap,w=new WeakMap,R=new WeakMap,E=new WeakMap,m=new WeakMap,O=new WeakMap,C=new WeakMap,U=new WeakMap,L=new WeakMap,P=new WeakMap,G=new WeakMap,f=new WeakMap,b=new WeakMap,j=new WeakMap,q=new WeakMap,c=new WeakSet,H=async function(e={}){for(let[o,x]of Object.entries(s(this,j))){if(x instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let d=await x.setup(this,{},!0);if(d.emscriptenOpts&&console.warn(`PGlite extension ${o} returned emscriptenOpts, these are not supported on the client side of a worker`),d.namespaceObj){let u=this;u[o]=d.namespaceObj}d.bundlePath&&console.warn(`PGlite extension ${o} returned bundlePath, this is not supported on the client side of a worker`),d.init&&await d.init(),d.close&&s(this,q).push(d.close)}}await s(this,C);let{extensions:t,...a}=e;s(this,m).postMessage({type:"init",options:a}),await s(this,U);let n=`pglite-tab-close:${s(this,R)}`;h(this,G,await J(n));let i=`pglite-broadcast:${s(this,O)}`;h(this,L,new BroadcastChannel(i));let y=`pglite-tab:${s(this,R)}`;h(this,P,new BroadcastChannel(y)),s(this,L).addEventListener("message",async o=>{o.data.type==="leader-here"?(h(this,E,!1),s(this,w).dispatchEvent(new Event("leader-change")),p(this,c,S).call(this)):o.data.type==="notify"&&p(this,c,z).call(this,o.data.channel,o.data.payload)}),s(this,P).addEventListener("message",async o=>{o.data.type==="connected"&&(h(this,E,!0),s(this,w).dispatchEvent(new Event("connected")),h(this,W,await p(this,c,g).call(this,"getDebugLevel")),h(this,A,!0))}),s(this,m).addEventListener("message",async o=>{o.data.type==="leader-now"&&(h(this,I,!0),s(this,w).dispatchEvent(new Event("leader-change")))}),p(this,c,S).call(this)},S=async function(){s(this,E)||(s(this,L).postMessage({type:"tab-here",id:s(this,R)}),setTimeout(()=>p(this,c,S).call(this),16))},g=async function(e,...t){let a=D(),n={type:"rpc-call",callId:a,method:e,args:t};return s(this,P).postMessage(n),await new Promise((i,y)=>{let o=u=>{if(u.data.callId!==a)return;d();let k=u.data;if(k.type==="rpc-return")i(k.result);else if(k.type==="rpc-error"){let v=new Error(k.error.message);Object.assign(v,k.error),y(v)}else y(new Error("Invalid message"))},x=()=>{d(),y(new $)},d=()=>{s(this,P).removeEventListener("message",o),s(this,w).removeEventListener("leader-change",x)};s(this,w).addEventListener("leader-change",x),s(this,P).addEventListener("message",o)})},z=function(e,t){let a=s(this,f).get(e);if(a)for(let n of a)queueMicrotask(()=>n(t));for(let n of s(this,b))queueMicrotask(()=>n(e,t))};var _=F;async function se({init:r}){postMessage({type:"here"});let e=await new Promise(d=>{addEventListener("message",u=>{u.data.type==="init"&&d(u.data.options)},{once:!0})}),t=e.id??`${Q}:${e.dataDir??""}`;postMessage({type:"ready",id:t});let a=`pglite-election-lock:${t}`,n=`pglite-broadcast:${t}`,i=new BroadcastChannel(n),y=new Set;await J(a);let o=r(e);i.onmessage=async d=>{let u=d.data;switch(u.type){case"tab-here":ae(u.id,await o,y);break}},i.postMessage({type:"leader-here",id:t}),postMessage({type:"leader-now"}),(await o).onNotification((d,u)=>{i.postMessage({type:"notify",channel:d,payload:u})})}function ae(r,e,t){if(t.has(r))return;t.add(r);let a=`pglite-tab:${r}`,n=`pglite-tab-close:${r}`,i=new BroadcastChannel(a);navigator.locks.request(n,()=>new Promise(o=>{i.close(),t.delete(r),o()}));let y=ne(e);i.addEventListener("message",async o=>{let x=o.data;switch(x.type){case"rpc-call":{let{callId:d,method:u,args:k}=x;try{let v=await y[u](...k);i.postMessage({type:"rpc-return",callId:d,result:v})}catch(v){console.error(v),i.postMessage({type:"rpc-error",callId:d,error:{message:v.message}})}break}}}),i.postMessage({type:"connected"})}function ne(r){let e=new Map;return{async getDebugLevel(){return r.debug},async close(){await r.close()},async query(t,a,n){return await r.query(t,a,n)},async sql(t,a,n){let i=t;return i.raw=a,await r.sql(i,...n)},async exec(t,a){return await r.exec(t,a)},async transactionStart(){let t=D(),{promise:a,resolve:n}=ie();return e.set(t,a),r.transaction(i=>new Promise((y,o)=>{n({tx:i,resolve:y,reject:o})})),t},async transactionCommit(t){if(!e.has(t))throw new Error("No transaction");(await e.get(t)).resolve(),e.delete(t)},async transactionQuery(t,a,n,i){if(!e.has(t))throw new Error("No transaction");return await(await e.get(t)).tx.query(a,n,i)},async transactionExec(t,a,n){if(!e.has(t))throw new Error("No transaction");return(await e.get(t)).tx.exec(a,n)},async transactionRollback(t){if(!e.has(t))throw new Error("No transaction");let a=await e.get(t);await a.tx.rollback(),a.reject(new Error("Transaction rolled back")),e.delete(t)},async execProtocol(t){return await r.execProtocol(t)},async execProtocolRaw(t){return await r.execProtocolRaw(t)},async dumpDataDir(){return await r.dumpDataDir()}}}var $=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function J(r){let e;return await new Promise(t=>{navigator.locks.request(r,()=>new Promise(a=>{e=a,t()}))}),e}function ie(){let r,e;return{promise:new Promise((a,n)=>{r=a,e=n}),resolve:r,reject:e}}0&&(module.exports={LeaderChangedError,PGliteWorker,worker});
//# sourceMappingURL=index.cjs.map