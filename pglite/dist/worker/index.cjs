"use strict";var q=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var X=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var V=r=>{throw TypeError(r)};var Z=(r,e)=>{for(var t in e)q(r,t,{get:e[t],enumerable:!0})},ee=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of X(e))!Y.call(r,a)&&a!==t&&q(r,a,{get:()=>e[a],enumerable:!(n=K(e,a))||n.enumerable});return r};var te=r=>ee(q({},"__esModule",{value:!0}),r);var B=(r,e,t)=>e.has(r)||V("Cannot "+t);var s=(r,e,t)=>(B(r,e,"read from private field"),t?t.call(r):e.get(r)),l=(r,e,t)=>e.has(r)?V("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),h=(r,e,t,n)=>(B(r,e,"write to private field"),n?n.call(r,t):e.set(r,t),t),p=(r,e,t)=>(B(r,e,"access private method"),t);var oe={};Z(oe,{LeaderChangedError:()=>S,PGliteWorker:()=>_,worker:()=>se});module.exports=te(oe);var re=()=>typeof document>"u"?new URL(`file:${__filename}`).href:document.currentScript&&document.currentScript.src||new URL("main.js",document.baseURI).href,Q=re();var de=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var D=()=>{if(globalThis.crypto?.randomUUID)return globalThis.crypto.randomUUID();let r=new Uint8Array(16);if(globalThis.crypto?.getRandomValues)globalThis.crypto.getRandomValues(r);else for(let t=0;t<r.length;t++)r[t]=Math.floor(Math.random()*256);r[6]=r[6]&15|64,r[8]=r[8]&63|128;let e=[];return r.forEach(t=>{e.push(t.toString(16).padStart(2,"0"))}),e.slice(0,4).join("")+"-"+e.slice(4,6).join("")+"-"+e.slice(6,8).join("")+"-"+e.slice(8,10).join("")+"-"+e.slice(10).join("")};var M,T,I,W,O,w,R,E,m,A,C,U,L,k,G,f,b,j,N,c,H,$,g,z,F=class F{constructor(e,t){l(this,c);l(this,M);l(this,T,0);l(this,I,!1);l(this,W,!1);l(this,O,!1);l(this,w,new EventTarget);l(this,R);l(this,E,!1);l(this,m);l(this,A);l(this,C);l(this,U);l(this,L);l(this,k);l(this,G);l(this,f,new Map);l(this,b,new Set);l(this,j);l(this,N,[]);h(this,m,e),h(this,R,D()),h(this,j,t?.extensions??{}),h(this,C,new Promise(n=>{s(this,m).addEventListener("message",a=>{if(a.data.type==="here")n();else throw new Error("Invalid message")},{once:!0})})),h(this,U,new Promise(n=>{let a=i=>{i.data.type==="ready"&&(h(this,A,i.data.id),s(this,m).removeEventListener("message",a),n())};s(this,m).addEventListener("message",a)})),h(this,M,p(this,c,H).call(this,t))}static async create(e,t){let n=new F(e,t);return await s(n,M),n}get waitReady(){return new Promise(e=>{s(this,M).then(()=>{s(this,E)?e():e(new Promise(t=>{s(this,w).addEventListener("connected",()=>{t()})}))})})}get debug(){return s(this,T)}get ready(){return s(this,I)}get closed(){return s(this,W)}get isLeader(){return s(this,O)}async close(){var e;s(this,W)||(h(this,W,!0),s(this,L)?.close(),s(this,k)?.close(),(e=s(this,G))==null||e.call(this),s(this,m).terminate())}async[Symbol.asyncDispose](){await this.close()}async query(e,t,n){return await this.waitReady,await p(this,c,g).call(this,"query",e,t,n)}async exec(e,t){return await this.waitReady,await p(this,c,g).call(this,"exec",e,t)}async transaction(e){await this.waitReady;let t=await p(this,c,g).call(this,"transactionStart"),n;try{n=await e({query:async(a,i,y)=>await p(this,c,g).call(this,"transactionQuery",t,a,i,y),exec:async(a,i)=>await p(this,c,g).call(this,"transactionExec",t,a,i),rollback:async()=>{await p(this,c,g).call(this,"transactionRollback",t)},closed:!1})}catch(a){throw await p(this,c,g).call(this,"transactionRollback",t),a}return await p(this,c,g).call(this,"transactionCommit",t),n}async execProtocolRaw(e){return await this.waitReady,await p(this,c,g).call(this,"execProtocolRaw",e)}async execProtocol(e){return await this.waitReady,await p(this,c,g).call(this,"execProtocol",e)}async listen(e,t){return await this.waitReady,s(this,f).has(e)||s(this,f).set(e,new Set),s(this,f).get(e)?.add(t),await this.exec(`LISTEN ${e}`),async()=>{await this.unlisten(e,t)}}async unlisten(e,t){await this.waitReady,t?s(this,f).get(e)?.delete(t):s(this,f).delete(e),s(this,f).get(e)?.size===0&&await this.exec(`UNLISTEN ${e}`)}onNotification(e){return s(this,b).add(e),()=>{s(this,b).delete(e)}}offNotification(e){s(this,b).delete(e)}async dumpDataDir(){return await p(this,c,g).call(this,"dumpDataDir")}onLeaderChange(e){return s(this,w).addEventListener("leader-change",e),()=>{s(this,w).removeEventListener("leader-change",e)}}offLeaderChange(e){s(this,w).removeEventListener("leader-change",e)}};M=new WeakMap,T=new WeakMap,I=new WeakMap,W=new WeakMap,O=new WeakMap,w=new WeakMap,R=new WeakMap,E=new WeakMap,m=new WeakMap,A=new WeakMap,C=new WeakMap,U=new WeakMap,L=new WeakMap,k=new WeakMap,G=new WeakMap,f=new WeakMap,b=new WeakMap,j=new WeakMap,N=new WeakMap,c=new WeakSet,H=async function(e={}){for(let[o,x]of Object.entries(s(this,j))){if(x instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let d=await x.setup(this,{},!0);if(d.emscriptenOpts&&console.warn(`PGlite extension ${o} returned emscriptenOpts, these are not supported on the client side of a worker`),d.namespaceObj){let u=this;u[o]=d.namespaceObj}d.bundlePath&&console.warn(`PGlite extension ${o} returned bundlePath, this is not supported on the client side of a worker`),d.init&&await d.init(),d.close&&s(this,N).push(d.close)}}await s(this,C);let{extensions:t,...n}=e;s(this,m).postMessage({type:"init",options:n}),await s(this,U);let a=`pglite-tab-close:${s(this,R)}`;h(this,G,await J(a));let i=`pglite-broadcast:${s(this,A)}`;h(this,L,new BroadcastChannel(i));let y=`pglite-tab:${s(this,R)}`;h(this,k,new BroadcastChannel(y)),s(this,L).addEventListener("message",async o=>{o.data.type==="leader-here"?(h(this,E,!1),s(this,w).dispatchEvent(new Event("leader-change")),p(this,c,$).call(this)):o.data.type==="notify"&&p(this,c,z).call(this,o.data.channel,o.data.payload)}),s(this,k).addEventListener("message",async o=>{o.data.type==="connected"&&(h(this,E,!0),s(this,w).dispatchEvent(new Event("connected")),h(this,T,await p(this,c,g).call(this,"getDebugLevel")),h(this,I,!0))}),s(this,m).addEventListener("message",async o=>{o.data.type==="leader-now"&&(h(this,O,!0),s(this,w).dispatchEvent(new Event("leader-change")))}),p(this,c,$).call(this)},$=async function(){s(this,E)||(s(this,L).postMessage({type:"tab-here",id:s(this,R)}),setTimeout(()=>p(this,c,$).call(this),16))},g=async function(e,...t){let n=D(),a={type:"rpc-call",callId:n,method:e,args:t};return s(this,k).postMessage(a),await new Promise((i,y)=>{let o=u=>{if(u.data.callId!==n)return;d();let P=u.data;if(P.type==="rpc-return")i(P.result);else if(P.type==="rpc-error"){let v=new Error(P.error.message);Object.assign(v,P.error),y(v)}else y(new Error("Invalid message"))},x=()=>{d(),y(new S)},d=()=>{s(this,k).removeEventListener("message",o),s(this,w).removeEventListener("leader-change",x)};s(this,w).addEventListener("leader-change",x),s(this,k).addEventListener("message",o)})},z=function(e,t){let n=s(this,f).get(e);if(n)for(let a of n)queueMicrotask(()=>a(t));for(let a of s(this,b))queueMicrotask(()=>a(e,t))};var _=F;async function se({init:r}){postMessage({type:"here"});let e=await new Promise(d=>{addEventListener("message",u=>{u.data.type==="init"&&d(u.data.options)},{once:!0})}),t=e.id??`${Q}:${e.dataDir??""}`;postMessage({type:"ready",id:t});let n=`pglite-election-lock:${t}`,a=`pglite-broadcast:${t}`,i=new BroadcastChannel(a),y=new Set;await J(n);let o=r(e);i.onmessage=async d=>{let u=d.data;switch(u.type){case"tab-here":ne(u.id,await o,y);break}},i.postMessage({type:"leader-here",id:t}),postMessage({type:"leader-now"}),(await o).onNotification((d,u)=>{i.postMessage({type:"notify",channel:d,payload:u})})}function ne(r,e,t){if(t.has(r))return;t.add(r);let n=`pglite-tab:${r}`,a=`pglite-tab-close:${r}`,i=new BroadcastChannel(n);navigator.locks.request(a,()=>new Promise(o=>{i.close(),t.delete(r),o()}));let y=ae(e);i.addEventListener("message",async o=>{let x=o.data;switch(x.type){case"rpc-call":{let{callId:d,method:u,args:P}=x;try{let v=await y[u](...P);i.postMessage({type:"rpc-return",callId:d,result:v})}catch(v){console.error(v),i.postMessage({type:"rpc-error",callId:d,error:{message:v.message}})}break}}}),i.postMessage({type:"connected"})}function ae(r){let e=new Map;return{async getDebugLevel(){return r.debug},async close(){await r.close()},async query(t,n,a){return await r.query(t,n,a)},async exec(t,n){return await r.exec(t,n)},async transactionStart(){let t=D(),{promise:n,resolve:a}=ie();return e.set(t,n),r.transaction(i=>new Promise((y,o)=>{a({tx:i,resolve:y,reject:o})})),t},async transactionCommit(t){if(!e.has(t))throw new Error("No transaction");(await e.get(t)).resolve(),e.delete(t)},async transactionQuery(t,n,a,i){if(!e.has(t))throw new Error("No transaction");return await(await e.get(t)).tx.query(n,a,i)},async transactionExec(t,n,a){if(!e.has(t))throw new Error("No transaction");return(await e.get(t)).tx.exec(n,a)},async transactionRollback(t){if(!e.has(t))throw new Error("No transaction");let n=await e.get(t);await n.tx.rollback(),n.reject(new Error("Transaction rolled back")),e.delete(t)},async execProtocol(t){return await r.execProtocol(t)},async execProtocolRaw(t){return await r.execProtocolRaw(t)},async dumpDataDir(){return await r.dumpDataDir()}}}var S=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function J(r){let e;return await new Promise(t=>{navigator.locks.request(r,()=>new Promise(n=>{e=n,t()}))}),e}function ie(){let r,e;return{promise:new Promise((n,a)=>{r=n,e=a}),resolve:r,reject:e}}0&&(module.exports={LeaderChangedError,PGliteWorker,worker});
//# sourceMappingURL=index.cjs.map