{"version":3,"sources":["../../src/worker/index.ts"],"sourcesContent":["import type {\n  DebugLevel,\n  Extensions,\n  PGliteInterface,\n  PGliteInterfaceExtensions,\n  PGliteOptions,\n  QueryOptions,\n  Results,\n  Transaction,\n} from '../interface.js'\nimport { uuid } from '../utils.js'\nimport type { BackendMessage } from 'pg-protocol/src/messages.js'\n\nexport type PGliteWorkerOptions = PGliteOptions & {\n  meta?: any\n  id?: string\n}\n\nexport class PGliteWorker implements PGliteInterface, AsyncDisposable {\n  #initPromise: Promise<void>\n  #debug: DebugLevel = 0\n\n  #ready = false\n  #closed = false\n  #isLeader = false\n\n  #eventTarget = new EventTarget()\n\n  #tabId: string\n\n  #connected = false\n\n  #workerProcess: Worker\n  #workerID?: string\n  #workerHerePromise?: Promise<void>\n  #workerReadyPromise?: Promise<void>\n\n  #broadcastChannel?: BroadcastChannel\n  #tabChannel?: BroadcastChannel\n  #releaseTabCloseLock?: () => void\n\n  #notifyListeners = new Map<string, Set<(payload: string) => void>>()\n  #globalNotifyListeners = new Set<(channel: string, payload: string) => void>()\n\n  #extensions: Extensions\n  #extensionsClose: Array<() => Promise<void>> = []\n\n  constructor(worker: Worker, options?: PGliteWorkerOptions) {\n    this.#workerProcess = worker\n    this.#tabId = uuid()\n    this.#extensions = options?.extensions ?? {}\n\n    this.#workerHerePromise = new Promise<void>((resolve) => {\n      this.#workerProcess.addEventListener(\n        'message',\n        (event) => {\n          if (event.data.type === 'here') {\n            resolve()\n          } else {\n            throw new Error('Invalid message')\n          }\n        },\n        { once: true },\n      )\n    })\n\n    this.#workerReadyPromise = new Promise<void>((resolve) => {\n      const callback = (event: MessageEvent<any>) => {\n        if (event.data.type === 'ready') {\n          this.#workerID = event.data.id\n          this.#workerProcess.removeEventListener('message', callback)\n          resolve()\n        }\n      }\n      this.#workerProcess.addEventListener('message', callback)\n    })\n\n    this.#initPromise = this.#init(options)\n  }\n\n  /**\n   * Create a new PGlite instance with extensions on the Typescript interface\n   * This also awaits the instance to be ready before resolving\n   * (The main constructor does enable extensions, however due to the limitations\n   * of Typescript, the extensions are not available on the instance interface)\n   * @param worker The worker to use\n   * @param options Optional options\n   * @returns A promise that resolves to the PGlite instance when it's ready.\n   */\n  static async create<O extends PGliteWorkerOptions>(\n    worker: Worker,\n    options?: O,\n  ): Promise<PGliteWorker & PGliteInterfaceExtensions<O['extensions']>> {\n    const pg = new PGliteWorker(worker, options)\n    await pg.#initPromise\n    return pg as PGliteWorker & PGliteInterfaceExtensions<O['extensions']>\n  }\n\n  async #init(options: PGliteWorkerOptions = {}) {\n    // Setup the extensions\n    for (const [extName, ext] of Object.entries(this.#extensions)) {\n      if (ext instanceof URL) {\n        throw new Error(\n          'URL extensions are not supported on the client side of a worker',\n        )\n      } else {\n        const extRet = await ext.setup(this, {}, true)\n        if (extRet.emscriptenOpts) {\n          console.warn(\n            `PGlite extension ${extName} returned emscriptenOpts, these are not supported on the client side of a worker`,\n          )\n        }\n        if (extRet.namespaceObj) {\n          const instance = this as any\n          instance[extName] = extRet.namespaceObj\n        }\n        if (extRet.bundlePath) {\n          console.warn(\n            `PGlite extension ${extName} returned bundlePath, this is not supported on the client side of a worker`,\n          )\n        }\n        if (extRet.init) {\n          await extRet.init()\n        }\n        if (extRet.close) {\n          this.#extensionsClose.push(extRet.close)\n        }\n      }\n    }\n\n    // Wait for the worker let us know it's here\n    await this.#workerHerePromise\n\n    // Send the worker the options\n    const { extensions: _, ...workerOptions } = options\n    this.#workerProcess.postMessage({\n      type: 'init',\n      options: workerOptions,\n    })\n\n    // Wait for the worker let us know it's ready\n    await this.#workerReadyPromise\n\n    // Acquire the tab close lock, this is released then the tab, or this\n    // PGliteWorker instance, is closed\n    const tabCloseLockId = `pglite-tab-close:${this.#tabId}`\n    this.#releaseTabCloseLock = await acquireLock(tabCloseLockId)\n\n    // Start the broadcast channel used to communicate with tabs and leader election\n    const broadcastChannelId = `pglite-broadcast:${this.#workerID}`\n    this.#broadcastChannel = new BroadcastChannel(broadcastChannelId)\n\n    // Start the tab channel used to communicate with the leader directly\n    const tabChannelId = `pglite-tab:${this.#tabId}`\n    this.#tabChannel = new BroadcastChannel(tabChannelId)\n\n    this.#broadcastChannel.addEventListener('message', async (event) => {\n      if (event.data.type === 'leader-here') {\n        this.#connected = false\n        this.#eventTarget.dispatchEvent(new Event('leader-change'))\n        this.#leaderNotifyLoop()\n      } else if (event.data.type === 'notify') {\n        this.#receiveNotification(event.data.channel, event.data.payload)\n      }\n    })\n\n    this.#tabChannel.addEventListener('message', async (event) => {\n      if (event.data.type === 'connected') {\n        this.#connected = true\n        this.#eventTarget.dispatchEvent(new Event('connected'))\n        this.#debug = await this.#rpc('getDebugLevel')\n        this.#ready = true\n      }\n    })\n\n    this.#workerProcess.addEventListener('message', async (event) => {\n      if (event.data.type === 'leader-now') {\n        this.#isLeader = true\n        this.#eventTarget.dispatchEvent(new Event('leader-change'))\n      }\n    })\n\n    this.#leaderNotifyLoop()\n  }\n\n  async #leaderNotifyLoop() {\n    if (!this.#connected) {\n      this.#broadcastChannel!.postMessage({\n        type: 'tab-here',\n        id: this.#tabId,\n      })\n      setTimeout(() => this.#leaderNotifyLoop(), 16)\n    }\n  }\n\n  async #rpc<Method extends WorkerRpcMethod>(\n    method: Method,\n    ...args: Parameters<WorkerApi[Method]>\n  ): Promise<ReturnType<WorkerApi[Method]>> {\n    const callId = uuid()\n    const message: WorkerRpcCall<Method> = {\n      type: 'rpc-call',\n      callId,\n      method,\n      args,\n    }\n    this.#tabChannel!.postMessage(message)\n    return await new Promise<ReturnType<WorkerApi[Method]>>(\n      (resolve, reject) => {\n        const listener = (event: MessageEvent) => {\n          if (event.data.callId !== callId) return\n          cleanup()\n          const message: WorkerRpcResponse<Method> = event.data\n          if (message.type === 'rpc-return') {\n            resolve(message.result)\n          } else if (message.type === 'rpc-error') {\n            const error = new Error(message.error.message)\n            Object.assign(error, message.error)\n            reject(error)\n          } else {\n            reject(new Error('Invalid message'))\n          }\n        }\n        const leaderChangeListener = () => {\n          // If the leader changes, throw an error to reject the promise\n          cleanup()\n          reject(new LeaderChangedError())\n        }\n        const cleanup = () => {\n          this.#tabChannel!.removeEventListener('message', listener)\n          this.#eventTarget.removeEventListener(\n            'leader-change',\n            leaderChangeListener,\n          )\n        }\n        this.#eventTarget.addEventListener(\n          'leader-change',\n          leaderChangeListener,\n        )\n        this.#tabChannel!.addEventListener('message', listener)\n      },\n    )\n  }\n\n  get waitReady() {\n    return new Promise<void>((resolve) => {\n      this.#initPromise.then(() => {\n        if (!this.#connected) {\n          resolve(\n            new Promise<void>((resolve) => {\n              this.#eventTarget.addEventListener('connected', () => {\n                resolve()\n              })\n            }),\n          )\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  get debug() {\n    return this.#debug\n  }\n\n  /**\n   * The ready state of the database\n   */\n  get ready() {\n    return this.#ready\n  }\n\n  /**\n   * The closed state of the database\n   */\n  get closed() {\n    return this.#closed\n  }\n\n  /**\n   * The leader state of this tab\n   */\n  get isLeader() {\n    return this.#isLeader\n  }\n\n  /**\n   * Close the database\n   * @returns Promise that resolves when the connection to shared PGlite is closed\n   */\n  async close() {\n    if (this.#closed) {\n      return\n    }\n    this.#closed = true\n    this.#broadcastChannel?.close()\n    this.#tabChannel?.close()\n    this.#releaseTabCloseLock?.()\n    this.#workerProcess.terminate()\n  }\n\n  /**\n   * Close the database when the object exits scope\n   * Stage 3 ECMAScript Explicit Resource Management\n   * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#using-declarations-and-explicit-resource-management\n   */\n  async [Symbol.asyncDispose]() {\n    await this.close()\n  }\n\n  /**\n   * Execute a single SQL statement\n   * This uses the \"Extended Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    await this.waitReady\n    return (await this.#rpc('query', query, params, options)) as Results<T>\n  }\n\n  /**\n   * Execute a SQL query, this can have multiple statements.\n   * This uses the \"Simple Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @returns The result of the query\n   */\n  async exec(query: string, options?: QueryOptions): Promise<Array<Results>> {\n    await this.waitReady\n    return (await this.#rpc('exec', query, options)) as Array<Results>\n  }\n\n  /**\n   * Execute a transaction\n   * @param callback A callback function that takes a transaction object\n   * @returns The result of the transaction\n   */\n  async transaction<T>(\n    callback: (tx: Transaction) => Promise<T>,\n  ): Promise<T | undefined> {\n    await this.waitReady\n    const txId = await this.#rpc('transactionStart')\n    let ret: T | undefined\n    try {\n      ret = await callback({\n        query: async (query, params, options) => {\n          return await this.#rpc(\n            'transactionQuery',\n            txId,\n            query,\n            params,\n            options,\n          )\n        },\n        exec: async (query, options) => {\n          return (await this.#rpc(\n            'transactionExec',\n            txId,\n            query,\n            options,\n          )) as any\n        },\n        rollback: async () => {\n          await this.#rpc('transactionRollback', txId)\n        },\n        closed: false,\n      } as Transaction)\n    } catch (error) {\n      await this.#rpc('transactionRollback', txId)\n      throw error\n    }\n    await this.#rpc('transactionCommit', txId)\n    return ret\n  }\n\n  /**\n   * Execute a postgres wire protocol message directly without wrapping the response.\n   * Only use if `execProtocol()` doesn't suite your needs.\n   *\n   * **Warning:** This bypasses PGlite's protocol wrappers that manage error/notice messages,\n   * transactions, and notification listeners. Only use if you need to bypass these wrappers and\n   * don't intend to use the above features.\n   *\n   * @param message The postgres wire protocol message to execute\n   * @returns The direct message data response produced by Postgres\n   */\n  async execProtocolRaw(message: Uint8Array): Promise<Uint8Array> {\n    await this.waitReady\n    return (await this.#rpc('execProtocolRaw', message)) as Uint8Array\n  }\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  async execProtocol(\n    message: Uint8Array,\n  ): Promise<Array<[BackendMessage, Uint8Array]>> {\n    await this.waitReady\n    return (await this.#rpc('execProtocol', message)) as Array<\n      [BackendMessage, Uint8Array]\n    >\n  }\n\n  /**\n   * Listen for a notification\n   * @param channel The channel to listen on\n   * @param callback The callback to call when a notification is received\n   */\n  async listen(\n    channel: string,\n    callback: (payload: string) => void,\n  ): Promise<() => Promise<void>> {\n    await this.waitReady\n    if (!this.#notifyListeners.has(channel)) {\n      this.#notifyListeners.set(channel, new Set())\n    }\n    this.#notifyListeners.get(channel)?.add(callback)\n    await this.exec(`LISTEN ${channel}`)\n    return async () => {\n      await this.unlisten(channel, callback)\n    }\n  }\n\n  /**\n   * Stop listening for a notification\n   * @param channel The channel to stop listening on\n   * @param callback The callback to remove\n   */\n  async unlisten(\n    channel: string,\n    callback?: (payload: string) => void,\n  ): Promise<void> {\n    await this.waitReady\n    if (callback) {\n      this.#notifyListeners.get(channel)?.delete(callback)\n    } else {\n      this.#notifyListeners.delete(channel)\n    }\n    if (this.#notifyListeners.get(channel)?.size === 0) {\n      // As we currently have a dedicated worker we can just unlisten\n      await this.exec(`UNLISTEN ${channel}`)\n    }\n  }\n\n  /**\n   * Listen to notifications\n   * @param callback The callback to call when a notification is received\n   */\n  onNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.add(callback)\n    return () => {\n      this.#globalNotifyListeners.delete(callback)\n    }\n  }\n\n  /**\n   * Stop listening to notifications\n   * @param callback The callback to remove\n   */\n  offNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.delete(callback)\n  }\n\n  #receiveNotification(channel: string, payload: string) {\n    const listeners = this.#notifyListeners.get(channel)\n    if (listeners) {\n      for (const listener of listeners) {\n        queueMicrotask(() => listener(payload))\n      }\n    }\n    for (const listener of this.#globalNotifyListeners) {\n      queueMicrotask(() => listener(channel, payload))\n    }\n  }\n\n  async dumpDataDir(): Promise<File | Blob> {\n    return (await this.#rpc('dumpDataDir')) as File | Blob\n  }\n\n  onLeaderChange(callback: () => void) {\n    this.#eventTarget.addEventListener('leader-change', callback)\n    return () => {\n      this.#eventTarget.removeEventListener('leader-change', callback)\n    }\n  }\n\n  offLeaderChange(callback: () => void) {\n    this.#eventTarget.removeEventListener('leader-change', callback)\n  }\n}\n\nexport interface WorkerOptions {\n  init: (\n    options: Exclude<PGliteWorkerOptions, 'extensions'>,\n  ) => Promise<PGliteInterface>\n}\n\nexport async function worker({ init }: WorkerOptions) {\n  // Send a message to the main thread to let it know we are here\n  postMessage({ type: 'here' })\n\n  // Await the main thread to send us the options\n  const options = await new Promise<Exclude<PGliteWorkerOptions, 'extensions'>>(\n    (resolve) => {\n      addEventListener(\n        'message',\n        (event) => {\n          if (event.data.type === 'init') {\n            resolve(event.data.options)\n          }\n        },\n        { once: true },\n      )\n    },\n  )\n\n  // ID for this multi-tab worker - this is used to identify the group of workers\n  // that are trying to elect a leader for a shared PGlite instance.\n  // It defaults to the URL of the worker, and the dataDir if provided\n  // but can be overridden by the options.\n  const id = options.id ?? `${import.meta.url}:${options.dataDir ?? ''}`\n\n  // Let the main thread know we are ready\n  postMessage({ type: 'ready', id })\n\n  const electionLockId = `pglite-election-lock:${id}`\n  const broadcastChannelId = `pglite-broadcast:${id}`\n  const broadcastChannel = new BroadcastChannel(broadcastChannelId)\n  const connectedTabs = new Set<string>()\n\n  // Await the main lock which is used to elect the leader\n  // We don't release this lock, its automatically released when the worker or\n  // tab is closed\n  await acquireLock(electionLockId)\n\n  // Now we are the leader, start the worker\n  const dbPromise = init(options)\n\n  // Start listening for messages from tabs\n  broadcastChannel.onmessage = async (event) => {\n    const msg = event.data\n    switch (msg.type) {\n      case 'tab-here':\n        // A new tab has joined,\n        connectTab(msg.id, await dbPromise, connectedTabs)\n        break\n    }\n  }\n\n  // Notify the other tabs that we are the leader\n  broadcastChannel.postMessage({ type: 'leader-here', id })\n\n  // Let the main thread know we are the leader\n  postMessage({ type: 'leader-now' })\n\n  const db = await dbPromise\n\n  // Listen for notifications and broadcast them to all tabs\n  db.onNotification((channel, payload) => {\n    broadcastChannel.postMessage({ type: 'notify', channel, payload })\n  })\n}\n\nfunction connectTab(\n  tabId: string,\n  pg: PGliteInterface,\n  connectedTabs: Set<string>,\n) {\n  if (connectedTabs.has(tabId)) {\n    return\n  }\n  connectedTabs.add(tabId)\n  const tabChannelId = `pglite-tab:${tabId}`\n  const tabCloseLockId = `pglite-tab-close:${tabId}`\n  const tabChannel = new BroadcastChannel(tabChannelId)\n\n  // Use a tab close lock to unsubscribe the tab\n  navigator.locks.request(tabCloseLockId, () => {\n    return new Promise<void>((resolve) => {\n      // The tab has been closed, unsubscribe the tab broadcast channel\n      tabChannel.close()\n      connectedTabs.delete(tabId)\n      resolve()\n    })\n  })\n\n  const api = makeWorkerApi(pg)\n\n  tabChannel.addEventListener('message', async (event) => {\n    const msg = event.data\n    switch (msg.type) {\n      case 'rpc-call': {\n        const { callId, method, args } = msg as WorkerRpcCall<WorkerRpcMethod>\n        try {\n          // @ts-ignore no apparent reason why it fails\n          const result = (await api[method](...args)) as WorkerRpcResult<\n            typeof method\n          >['result']\n          tabChannel.postMessage({\n            type: 'rpc-return',\n            callId,\n            result,\n          } satisfies WorkerRpcResult<typeof method>)\n        } catch (error) {\n          console.error(error)\n          tabChannel.postMessage({\n            type: 'rpc-error',\n            callId,\n            error: { message: (error as Error).message },\n          } satisfies WorkerRpcError)\n        }\n        break\n      }\n    }\n  })\n\n  // Send a message to the tab to let it know it's connected\n  tabChannel.postMessage({ type: 'connected' })\n}\n\nfunction makeWorkerApi(db: PGliteInterface) {\n  const transactions = new Map<\n    string,\n    Promise<{\n      tx: Transaction\n      resolve: () => void\n      reject: (error: any) => void\n    }>\n  >()\n\n  return {\n    async getDebugLevel() {\n      return db.debug\n    },\n    async close() {\n      await db.close()\n    },\n    async query(query: string, params?: any[], options?: QueryOptions) {\n      return await db.query(query, params, options)\n    },\n    async exec(query: string, options?: QueryOptions) {\n      return await db.exec(query, options)\n    },\n    async transactionStart() {\n      const txId = uuid()\n      const { promise: txPromise, resolve: resolveTxPromise } = makePromise<{\n        tx: Transaction\n        resolve: () => void\n        reject: (error: any) => void\n      }>()\n      transactions.set(txId, txPromise)\n      db.transaction((newTx) => {\n        return new Promise<void>((resolveTx, rejectTx) => {\n          resolveTxPromise({\n            tx: newTx,\n            resolve: resolveTx,\n            reject: rejectTx,\n          })\n        })\n      })\n      return txId\n    },\n    async transactionCommit(id: string) {\n      if (!transactions.has(id)) {\n        throw new Error('No transaction')\n      }\n      const trnasaction = await transactions.get(id)!\n      trnasaction.resolve()\n\n      transactions.delete(id)\n    },\n    async transactionQuery<T>(\n      id: string,\n      query: string,\n      params?: any[],\n      options?: QueryOptions,\n    ) {\n      if (!transactions.has(id)) {\n        throw new Error('No transaction')\n      }\n      const tx = (await transactions.get(id)!).tx\n      return await tx.query<T>(query, params, options)\n    },\n    async transactionExec(id: string, query: string, options?: QueryOptions) {\n      if (!transactions.has(id)) {\n        throw new Error('No transaction')\n      }\n      const tx = (await transactions.get(id)!).tx\n      return tx.exec(query, options)\n    },\n    async transactionRollback(id: string) {\n      if (!transactions.has(id)) {\n        throw new Error('No transaction')\n      }\n      const tx = await transactions.get(id)!\n      await tx.tx.rollback()\n      tx.reject(new Error('Transaction rolled back'))\n      transactions.delete(id)\n    },\n    async execProtocol(message: Uint8Array) {\n      return await db.execProtocol(message)\n    },\n    async execProtocolRaw(message: Uint8Array) {\n      return await db.execProtocolRaw(message)\n    },\n    async dumpDataDir() {\n      return await db.dumpDataDir()\n    },\n  }\n}\n\nexport class LeaderChangedError extends Error {\n  constructor() {\n    super('Leader changed, pending operation in indeterminate state')\n  }\n}\n\nasync function acquireLock(lockId: string) {\n  let release\n  await new Promise<void>((resolve) => {\n    navigator.locks.request(lockId, () => {\n      return new Promise<void>((releaseCallback) => {\n        release = releaseCallback\n        resolve()\n      })\n    })\n  })\n  return release\n}\n\nfunction makePromise<T>() {\n  let resolve: (value: T) => void\n  let reject: (error: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { promise, resolve: resolve!, reject: reject! }\n}\n\ntype WorkerApi = ReturnType<typeof makeWorkerApi>\n\ntype WorkerRpcMethod = keyof WorkerApi\n\ntype WorkerRpcCall<Method extends WorkerRpcMethod> = {\n  type: 'rpc-call'\n  callId: string\n  method: Method\n  args: Parameters<WorkerApi[Method]>\n}\n\ntype WorkerRpcResult<Method extends WorkerRpcMethod> = {\n  type: 'rpc-return'\n  callId: string\n  result: ReturnType<WorkerApi[Method]>\n}\n\ntype WorkerRpcError = {\n  type: 'rpc-error'\n  callId: string\n  error: any\n}\n\ntype WorkerRpcResponse<Method extends WorkerRpcMethod> =\n  | WorkerRpcResult<Method>\n  | WorkerRpcError\n"],"mappings":"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","names":["init_esm_shims","_initPromise","_debug","_ready","_closed","_isLeader","_eventTarget","_tabId","_connected","_workerProcess","_workerID","_workerHerePromise","_workerReadyPromise","_broadcastChannel","_tabChannel","_releaseTabCloseLock","_notifyListeners","_globalNotifyListeners","_extensions","_extensionsClose","_PGliteWorker_instances","init_fn","leaderNotifyLoop_fn","rpc_fn","receiveNotification_fn","_PGliteWorker","worker","options","__privateAdd","__privateSet","uuid","resolve","__privateGet","event","callback","__privateMethod","pg","_a","query","params","txId","ret","error","message","channel","extName","ext","extRet","instance","_","workerOptions","tabCloseLockId","acquireLock","broadcastChannelId","tabChannelId","method","args","callId","reject","listener","cleanup","leaderChangeListener","LeaderChangedError","payload","listeners","PGliteWorker","init","id","electionLockId","broadcastChannel","connectedTabs","dbPromise","msg","connectTab","tabId","tabChannel","api","makeWorkerApi","result","db","transactions","txPromise","resolveTxPromise","makePromise","newTx","resolveTx","rejectTx","tx","lockId","release","releaseCallback","res","rej"]}