{"version":3,"sources":["../../src/live/index.ts"],"sourcesContent":["import type {\n  Extension,\n  PGliteInterface,\n  Results,\n  Transaction,\n} from \"../interface\";\nimport type {\n  LiveNamespace,\n  LiveQueryReturn,\n  LiveChangesReturn,\n  Change,\n} from \"./interface\";\n\nconst setup = async (pg: PGliteInterface, emscriptenOpts: any) => {\n  // Counter use to generate unique IDs for live queries\n  // This is used to create temporary views and so are scoped to the current connection\n  let liveQueryCounter = 0;\n\n  // The notify triggers are only ever added and never removed\n  // Keep track of which triggers have been added to avoid adding them multiple times\n  const tableNotifyTriggersAdded = new Set<string>();\n\n  const namespaceObj: LiveNamespace = {\n    async query<T>(\n      query: string,\n      params: any[] | undefined | null,\n      callback: (results: Results<T>) => void\n    ) {\n      const id = liveQueryCounter++;\n\n      let results: Results<T>;\n      let tables: { table_name: string; schema_name: string }[];\n\n      await pg.transaction(async (tx) => {\n        // Create a temporary view with the query\n        await tx.query(\n          `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${query}`,\n          params ?? []\n        );\n\n        // Get the tables used in the view and add triggers to notify when they change\n        tables = await getTablesForView(tx, `live_query_${id}_view`);\n        await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded);\n\n        // Create prepared statement to get the results\n        await tx.exec(`\n          PREPARE live_query_${id}_get AS\n          SELECT * FROM live_query_${id}_view;\n        `);\n\n        // Get the initial results\n        results = await tx.query<T>(`EXECUTE live_query_${id}_get;`);\n      });\n\n      // Function to refresh the query\n      const refresh = async () => {\n        results = await pg.query<T>(`EXECUTE live_query_${id}_get;`);\n        callback(results);\n      };\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = [];\n      for (const table of tables!) {\n        const unsub = await pg.listen(\n          `table_change__${table.schema_name}__${table.table_name}`,\n          async () => {\n            refresh();\n          }\n        );\n        unsubList.push(unsub);\n      }\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async () => {\n        for (const unsub of unsubList) {\n          await unsub();\n        }\n        await pg.exec(`\n          DROP VIEW IF EXISTS live_query_${id}_view;\n          DEALLOCATE live_query_${id}_get;\n        `);\n      };\n\n      // Run the callback with the initial results\n      callback(results!);\n\n      // Return the initial results\n      return {\n        initialResults: results!,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQueryReturn<T>;\n    },\n\n    async changes<T>(\n      query: string,\n      params: any[] | undefined | null,\n      key: string,\n      callback: (changes: Array<Change<T>>) => void\n    ) {\n      const id = liveQueryCounter++;\n      let tables: { table_name: string; schema_name: string }[];\n      let stateSwitch: 1 | 2 = 1;\n      let changes: Results<Change<T>>;\n\n      await pg.transaction(async (tx) => {\n        // Create a temporary view with the query\n        await tx.query(\n          `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${query}`,\n          params ?? []\n        );\n\n        // Get the tables used in the view and add triggers to notify when they change\n        tables = await getTablesForView(tx, `live_query_${id}_view`);\n        await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded);\n\n        // Get the columns of the view\n        const columns = [\n          ...(\n            await tx.query<any>(`\n              SELECT column_name, data_type \n              FROM information_schema.columns \n              WHERE table_name = 'live_query_${id}_view'\n            `)\n          ).rows,\n          { column_name: \"__after__\", data_type: \"integer\" },\n        ];\n\n        // Init state tables as empty temp table\n        await tx.exec(`\n          CREATE TEMP TABLE live_query_${id}_state1 (LIKE live_query_${id}_view INCLUDING ALL);\n          CREATE TEMP TABLE live_query_${id}_state2 (LIKE live_query_${id}_view INCLUDING ALL);\n        `);\n\n        // Create Diff views and prepared statements\n        for (const curr of [1, 2]) {\n          const prev = curr === 1 ? 2 : 1;\n          await tx.exec(`\n            PREPARE live_query_${id}_diff${curr} AS\n            WITH\n              prev AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${prev}),\n              curr AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${curr}),\n              data_diff AS (\n                -- INSERT operations: Include all columns\n                SELECT \n                  'INSERT' AS __op__,\n                  ${columns\n                    .map(\n                      ({ column_name }) =>\n                        `curr.\"${column_name}\" AS \"${column_name}\"`\n                    )\n                    .join(\",\\n\")},\n                  ARRAY[]::text[] AS __changed_columns__\n                FROM curr\n                LEFT JOIN prev ON curr.${key} = prev.${key}\n                WHERE prev.${key} IS NULL\n              UNION ALL\n                -- DELETE operations: Include only the primary key\n                SELECT \n                  'DELETE' AS __op__,\n                  ${columns\n                    .map(({ column_name, data_type }) => {\n                      if (column_name === key) {\n                        return `prev.\"${column_name}\" AS \"${column_name}\"`;\n                      } else {\n                        return `NULL::${data_type} AS \"${column_name}\"`;\n                      }\n                    })\n                    .join(\",\\n\")},\n                    ARRAY[]::text[] AS __changed_columns__\n                FROM prev\n                LEFT JOIN curr ON prev.${key} = curr.${key}\n                WHERE curr.${key} IS NULL\n              UNION ALL\n                -- UPDATE operations: Include only changed columns\n                SELECT \n                  'UPDATE' AS __op__,\n                  ${columns\n                    .map(({ column_name, data_type }) =>\n                      column_name === key\n                        ? `curr.\"${column_name}\" AS \"${column_name}\"`\n                        : `CASE \n                            WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                            THEN curr.\"${column_name}\"\n                            ELSE NULL::${data_type} \n                            END AS \"${column_name}\"`\n                    )\n                    .join(\",\\n\")},\n                    ARRAY(SELECT unnest FROM unnest(ARRAY[${columns\n                      .filter(({ column_name }) => column_name !== key)\n                      .map(\n                        ({ column_name }) =>\n                          `CASE\n                            WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                            THEN '${column_name}' \n                            ELSE NULL \n                            END`\n                      )\n                      .join(\n                        \", \"\n                      )}]) WHERE unnest IS NOT NULL) AS __changed_columns__\n                FROM curr\n                INNER JOIN prev ON curr.${key} = prev.${key}\n                WHERE NOT (curr IS NOT DISTINCT FROM prev)\n              )\n            SELECT * FROM data_diff;\n          `);\n        }\n      });\n\n      const refresh = async () => {\n        await pg.transaction(async (tx) => {\n          // Populate the state table\n          await tx.exec(`\n            DELETE FROM live_query_${id}_state${stateSwitch};\n            INSERT INTO live_query_${id}_state${stateSwitch} \n              SELECT * FROM live_query_${id}_view;\n          `);\n\n          // Get the changes\n          changes = await tx.query<any>(\n            `EXECUTE live_query_${id}_diff${stateSwitch};`\n          );\n        });\n\n        // Switch state\n        stateSwitch = stateSwitch === 1 ? 2 : 1;\n\n        callback(changes!.rows);\n      };\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = [];\n      for (const table of tables!) {\n        const unsub = await pg.listen(\n          `table_change__${table.schema_name}__${table.table_name}`,\n          async () => {\n            refresh();\n          }\n        );\n        unsubList.push(unsub);\n      }\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async () => {\n        for (const unsub of unsubList) {\n          await unsub();\n        }\n        await pg.exec(`\n          DROP VIEW IF EXISTS live_query_${id}_view;\n          DROP TABLE IF EXISTS live_query_${id}_state1;\n          DROP TABLE IF EXISTS live_query_${id}_state2;\n          DEALLOCATE live_query_${id}_diff1;\n          DEALLOCATE live_query_${id}_diff2;\n        `);\n      };\n\n      // Run the callback with the initial changes\n      await refresh();\n\n      // Fields\n      const fields = changes!.fields.filter(\n        (field) =>\n          ![\"__after__\", \"__op__\", \"__changed_columns__\"].includes(field.name)\n      );\n\n      // Return the initial results\n      return {\n        fields,\n        initialChanges: changes!.rows,\n        unsubscribe,\n        refresh,\n      } satisfies LiveChangesReturn<T>;\n    },\n\n    async incrementalQuery<T>(\n      query: string,\n      params: any[] | undefined | null,\n      key: string,\n      callback: (results: Results<Change<T>>) => void\n    ) {\n      const rowsMap: Map<any, any> = new Map();\n      const afterMap: Map<any, any> = new Map();\n      let lastRows: Change<T>[] = [];\n      let firstRun = true;\n\n      const { fields, unsubscribe, refresh } = await namespaceObj.changes<T>(\n        query,\n        params,\n        key,\n        (changes) => {\n          // Process the changes\n          for (const change of changes) {\n            const {\n              __op__: op,\n              __changed_columns__: changedColumns,\n              ...obj\n            } = change as typeof change & { [key: string]: any };\n            switch (op) {\n              case \"INSERT\":\n                rowsMap.set(obj[key], obj);\n                afterMap.set(obj.__after__, obj[key]);\n                break;\n              case \"DELETE\":\n                const oldObj = rowsMap.get(obj[key]);\n                rowsMap.delete(obj[key]);\n                afterMap.delete(oldObj.__after__);\n                break;\n              case \"UPDATE\":\n                const newObj = { ...(rowsMap.get(obj[key]) ?? {}) };\n                for (const columnName of changedColumns) {\n                  newObj[columnName] = obj[columnName];\n                  if (columnName === \"__after__\") {\n                    afterMap.set(obj.__after__, obj[key]);\n                  }\n                }\n                rowsMap.set(obj[key], newObj);\n                break;\n            }\n          }\n\n          // Get the rows in order\n          const rows: Change<T>[] = [];\n          let lastKey: any = null;\n          while (true) {\n            const nextKey = afterMap.get(lastKey);\n            const obj = rowsMap.get(nextKey);\n            if (!obj) {\n              break;\n            }\n            rows.push(obj);\n            lastKey = nextKey;\n          }\n          lastRows = rows;\n\n          // Run the callback\n          if (!firstRun) {\n            callback({\n              rows,\n              fields,\n            });\n          }\n        }\n      );\n\n      firstRun = false;\n      callback({\n        rows: lastRows,\n        fields,\n      });\n\n      return {\n        initialResults: {\n          rows: lastRows,\n          fields,\n        },\n        unsubscribe,\n        refresh,\n      } satisfies LiveQueryReturn<T>;\n    },\n  };\n\n  return {\n    namespaceObj,\n  };\n};\n\nexport const live = {\n  name: \"Live Queries\",\n  setup,\n} satisfies Extension;\n\n/**\n * Get a list of all the tables used in a view\n * @param tx a transaction or or PGlite instance\n * @param viewName the name of the view\n * @returns list of tables used in the view\n */\nasync function getTablesForView(\n  tx: Transaction | PGliteInterface,\n  viewName: string\n): Promise<{ table_name: string; schema_name: string }[]> {\n  return (\n    await tx.query<{\n      table_name: string;\n      schema_name: string;\n    }>(\n      `\n        SELECT DISTINCT\n          cl.relname AS table_name,\n          n.nspname AS schema_name\n        FROM pg_rewrite r\n        JOIN pg_depend d ON r.oid = d.objid\n        JOIN pg_class cl ON d.refobjid = cl.oid\n        JOIN pg_namespace n ON cl.relnamespace = n.oid\n        WHERE\n        r.ev_class = (\n            SELECT oid FROM pg_class WHERE relname = $1 AND relkind = 'v'\n        )\n        AND d.deptype = 'n';\n      `,\n      [viewName]\n    )\n  ).rows.filter((row) => row.table_name !== viewName);\n}\n\n/**\n * Add triggers to tables to notify when they change\n * @param tx a transaction or PGlite instance\n * @param tables list of tables to add triggers to\n */\nasync function addNotifyTriggersToTables(\n  tx: Transaction | PGliteInterface,\n  tables: { table_name: string; schema_name: string }[],\n  tableNotifyTriggersAdded: Set<string>\n) {\n  const triggers = tables\n    .filter(\n      (table) =>\n        !tableNotifyTriggersAdded.has(\n          `${table.schema_name}_${table.table_name}`\n        )\n    )\n    .map((table) => {\n      return `\n      CREATE OR REPLACE FUNCTION _notify_${table.schema_name}_${table.table_name}() RETURNS TRIGGER AS $$\n      BEGIN\n        PERFORM pg_notify('table_change__${table.schema_name}__${table.table_name}', '');\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n      CREATE OR REPLACE TRIGGER _notify_trigger_${table.schema_name}_${table.table_name}\n      AFTER INSERT OR UPDATE OR DELETE ON ${table.schema_name}.${table.table_name}\n      FOR EACH STATEMENT EXECUTE FUNCTION _notify_${table.schema_name}_${table.table_name}();\n      `;\n    })\n    .join(\"\\n\");\n  if (triggers.trim() !== \"\") {\n    await tx.exec(triggers);\n  }\n  tables.map((table) =>\n    tableNotifyTriggersAdded.add(`${table.schema_name}_${table.table_name}`)\n  );\n}\n"],"mappings":"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","names":["init_buffer","init_indirectEval","setup","pg","emscriptenOpts","liveQueryCounter","tableNotifyTriggersAdded","namespaceObj","query","params","callback","id","results","tables","tx","getTablesForView","addNotifyTriggersToTables","refresh","unsubList","table","unsub","unsubscribe","key","stateSwitch","changes","columns","curr","prev","column_name","data_type","field","rowsMap","afterMap","lastRows","firstRun","fields","change","op","changedColumns","obj","oldObj","newObj","columnName","rows","lastKey","nextKey","live","viewName","row","triggers"]}