{"version":3,"sources":["../src/utils.ts"],"sourcesContent":["export const IN_NODE =\n  typeof process === \"object\" &&\n  typeof process.versions === \"object\" &&\n  typeof process.versions.node === \"string\";\n\nexport async function makeLocateFile() {\n  const PGWASM_URL = new URL(\"../release/postgres.wasm\", import.meta.url);\n  const PGSHARE_URL = new URL(\"../release/postgres.data\", import.meta.url);\n  let fileURLToPath = (fileUrl: URL) => fileUrl.pathname;\n  if (IN_NODE) {\n    fileURLToPath = (await import(\"url\")).fileURLToPath;\n  }\n  return (base: string) => {\n    let url: URL | null = null;\n    switch (base) {\n      case \"postgres.data\":\n        url = PGSHARE_URL;\n        break;\n      case \"postgres.wasm\":\n        url = PGWASM_URL;\n        break;\n      default:\n        console.error(\"makeLocateFile\", base);\n    }\n\n    if (url?.protocol === \"file:\") {\n      return fileURLToPath(url);\n    }\n    return url?.toString() ?? \"\";\n  };\n}\n\nexport const uuid = (): string => {\n  // best case, `crypto.randomUUID` is available\n  if (globalThis.crypto?.randomUUID) {\n    return globalThis.crypto.randomUUID();\n  }\n\n  const bytes = new Uint8Array(16);\n\n  if (globalThis.crypto?.getRandomValues) {\n    // `crypto.getRandomValues` is available even in non-secure contexts\n    globalThis.crypto.getRandomValues(bytes);\n  } else {\n    // fallback to Math.random, if the Crypto API is completely missing\n    for (let i = 0; i < bytes.length; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n\n  bytes[6] = (bytes[6] & 0x0f) | 0x40; // Set the 4 most significant bits to 0100\n  bytes[8] = (bytes[8] & 0x3f) | 0x80; // Set the 2 most significant bits to 10\n\n  const hexValues: string[] = [];\n  bytes.forEach((byte) => {\n    hexValues.push(byte.toString(16).padStart(2, \"0\"));\n  });\n\n  return (\n    hexValues.slice(0, 4).join(\"\") +\n    \"-\" +\n    hexValues.slice(4, 6).join(\"\") +\n    \"-\" +\n    hexValues.slice(6, 8).join(\"\") +\n    \"-\" +\n    hexValues.slice(8, 10).join(\"\") +\n    \"-\" +\n    hexValues.slice(10).join(\"\")\n  );\n};\n"],"mappings":"wCAAAA,IAAO,IAAMC,EACX,OAAO,SAAY,UACnB,OAAO,QAAQ,UAAa,UAC5B,OAAO,QAAQ,SAAS,MAAS,SAEnC,eAAsBC,GAAiB,CACrC,IAAMC,EAAa,IAAI,IAAI,2BAA4B,YAAY,GAAG,EAChEC,EAAc,IAAI,IAAI,2BAA4B,YAAY,GAAG,EACnEC,EAAiBC,GAAiBA,EAAQ,SAC9C,OAAIL,IACFI,GAAiB,KAAM,QAAO,KAAK,GAAG,eAEhCE,GAAiB,CACvB,IAAIC,EAAkB,KACtB,OAAQD,EAAM,CACZ,IAAK,gBACHC,EAAMJ,EACN,MACF,IAAK,gBACHI,EAAML,EACN,MACF,QACE,QAAQ,MAAM,iBAAkBI,CAAI,CACxC,CAEA,OAAIC,GAAK,WAAa,QACbH,EAAcG,CAAG,EAEnBA,GAAK,SAAS,GAAK,EAC5B,CACF,CAEO,IAAMC,EAAO,IAAc,CAEhC,GAAI,WAAW,QAAQ,WACrB,OAAO,WAAW,OAAO,WAAW,EAGtC,IAAMC,EAAQ,IAAI,WAAW,EAAE,EAE/B,GAAI,WAAW,QAAQ,gBAErB,WAAW,OAAO,gBAAgBA,CAAK,MAGvC,SAASC,EAAI,EAAGA,EAAID,EAAM,OAAQC,IAChCD,EAAMC,CAAC,EAAI,KAAK,MAAM,KAAK,OAAO,EAAI,GAAG,EAI7CD,EAAM,CAAC,EAAKA,EAAM,CAAC,EAAI,GAAQ,GAC/BA,EAAM,CAAC,EAAKA,EAAM,CAAC,EAAI,GAAQ,IAE/B,IAAME,EAAsB,CAAC,EAC7B,OAAAF,EAAM,QAASG,GAAS,CACtBD,EAAU,KAAKC,EAAK,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CAAC,CACnD,CAAC,EAGCD,EAAU,MAAM,EAAG,CAAC,EAAE,KAAK,EAAE,EAC7B,IACAA,EAAU,MAAM,EAAG,CAAC,EAAE,KAAK,EAAE,EAC7B,IACAA,EAAU,MAAM,EAAG,CAAC,EAAE,KAAK,EAAE,EAC7B,IACAA,EAAU,MAAM,EAAG,EAAE,EAAE,KAAK,EAAE,EAC9B,IACAA,EAAU,MAAM,EAAE,EAAE,KAAK,EAAE,CAE/B","names":["init_esm_shims","IN_NODE","makeLocateFile","PGWASM_URL","PGSHARE_URL","fileURLToPath","fileUrl","base","url","uuid","bytes","i","hexValues","byte"]}