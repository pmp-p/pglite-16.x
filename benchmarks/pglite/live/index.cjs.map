{"version":3,"sources":["../../src/live/index.ts","../../src/utils.ts"],"sourcesContent":["import type {\n  Extension,\n  PGliteInterface,\n  Results,\n  Transaction,\n} from \"../interface\";\nimport type {\n  LiveNamespace,\n  LiveQueryReturn,\n  LiveChangesReturn,\n  Change,\n} from \"./interface\";\nimport { uuid } from \"../utils.js\";\n\nconst MAX_RETRIES = 5;\n\nconst setup = async (pg: PGliteInterface, emscriptenOpts: any) => {\n  // The notify triggers are only ever added and never removed\n  // Keep track of which triggers have been added to avoid adding them multiple times\n  const tableNotifyTriggersAdded = new Set<string>();\n\n  const namespaceObj: LiveNamespace = {\n    async query<T>(\n      query: string,\n      params: any[] | undefined | null,\n      callback: (results: Results<T>) => void,\n    ) {\n      const id = uuid().replace(/-/g, \"\");\n\n      let results: Results<T>;\n      let tables: { table_name: string; schema_name: string }[];\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${query}`,\n            params ?? [],\n          );\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`);\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded);\n\n          // Create prepared statement to get the results\n          await tx.exec(`\n            PREPARE live_query_${id}_get AS\n            SELECT * FROM live_query_${id}_view;\n          `);\n\n          // Get the initial results\n          results = await tx.query<T>(`EXECUTE live_query_${id}_get;`);\n        });\n      };\n      await init();\n\n      // Function to refresh the query\n      const refresh = async (count = 0) => {\n        try {\n          results = await pg.query<T>(`EXECUTE live_query_${id}_get;`);\n        } catch (e) {\n          const msg = (e as Error).message;\n          if (\n            msg == `prepared statement \"live_query_${id}_get\" does not exist`\n          ) {\n            // If the prepared statement does not exist, reset and try again\n            // This can happen if using the multi-tab worker\n            if (count > MAX_RETRIES) {\n              throw e;\n            }\n            await init();\n            refresh(count + 1);\n          } else {\n            throw e;\n          }\n        }\n        callback(results);\n      };\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = [];\n      for (const table of tables!) {\n        const unsub = await pg.listen(\n          `table_change__${table.schema_name}__${table.table_name}`,\n          async () => {\n            refresh();\n          },\n        );\n        unsubList.push(unsub);\n      }\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async () => {\n        for (const unsub of unsubList) {\n          await unsub();\n        }\n        await pg.exec(`\n          DROP VIEW IF EXISTS live_query_${id}_view;\n          DEALLOCATE live_query_${id}_get;\n        `);\n      };\n\n      // Run the callback with the initial results\n      callback(results!);\n\n      // Return the initial results\n      return {\n        initialResults: results!,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQueryReturn<T>;\n    },\n\n    async changes<T>(\n      query: string,\n      params: any[] | undefined | null,\n      key: string,\n      callback: (changes: Array<Change<T>>) => void,\n    ) {\n      const id = uuid().replace(/-/g, \"\");\n\n      let tables: { table_name: string; schema_name: string }[];\n      let stateSwitch: 1 | 2 = 1;\n      let changes: Results<Change<T>>;\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${query}`,\n            params ?? [],\n          );\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`);\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded);\n\n          // Get the columns of the view\n          const columns = [\n            ...(\n              await tx.query<any>(`\n                SELECT column_name, data_type, udt_name\n                FROM information_schema.columns \n                WHERE table_name = 'live_query_${id}_view'\n              `)\n            ).rows,\n            { column_name: \"__after__\", data_type: \"integer\" },\n          ];\n\n          // Init state tables as empty temp table\n          await tx.exec(`\n            CREATE TEMP TABLE live_query_${id}_state1 (LIKE live_query_${id}_view INCLUDING ALL);\n            CREATE TEMP TABLE live_query_${id}_state2 (LIKE live_query_${id}_view INCLUDING ALL);\n          `);\n\n          // Create Diff views and prepared statements\n          for (const curr of [1, 2]) {\n            const prev = curr === 1 ? 2 : 1;\n            await tx.exec(`\n              PREPARE live_query_${id}_diff${curr} AS\n              WITH\n                prev AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${prev}),\n                curr AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${curr}),\n                data_diff AS (\n                  -- INSERT operations: Include all columns\n                  SELECT \n                    'INSERT' AS __op__,\n                    ${columns\n                      .map(\n                        ({ column_name }) =>\n                          `curr.\"${column_name}\" AS \"${column_name}\"`,\n                      )\n                      .join(\",\\n\")},\n                    ARRAY[]::text[] AS __changed_columns__\n                  FROM curr\n                  LEFT JOIN prev ON curr.${key} = prev.${key}\n                  WHERE prev.${key} IS NULL\n                UNION ALL\n                  -- DELETE operations: Include only the primary key\n                  SELECT \n                    'DELETE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) => {\n                        if (column_name === key) {\n                          return `prev.\"${column_name}\" AS \"${column_name}\"`;\n                        } else {\n                          return `NULL::${data_type == \"USER-DEFINED\" ? udt_name : data_type} AS \"${column_name}\"`;\n                        }\n                      })\n                      .join(\",\\n\")},\n                      ARRAY[]::text[] AS __changed_columns__\n                  FROM prev\n                  LEFT JOIN curr ON prev.${key} = curr.${key}\n                  WHERE curr.${key} IS NULL\n                UNION ALL\n                  -- UPDATE operations: Include only changed columns\n                  SELECT \n                    'UPDATE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) =>\n                        column_name === key\n                          ? `curr.\"${column_name}\" AS \"${column_name}\"`\n                          : `CASE \n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN curr.\"${column_name}\"\n                              ELSE NULL::${data_type == \"USER-DEFINED\" ? udt_name : data_type} \n                              END AS \"${column_name}\"`,\n                      )\n                      .join(\",\\n\")},\n                      ARRAY(SELECT unnest FROM unnest(ARRAY[${columns\n                        .filter(({ column_name }) => column_name !== key)\n                        .map(\n                          ({ column_name }) =>\n                            `CASE\n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN '${column_name}' \n                              ELSE NULL \n                              END`,\n                        )\n                        .join(\n                          \", \",\n                        )}]) WHERE unnest IS NOT NULL) AS __changed_columns__\n                  FROM curr\n                  INNER JOIN prev ON curr.${key} = prev.${key}\n                  WHERE NOT (curr IS NOT DISTINCT FROM prev)\n                )\n              SELECT * FROM data_diff;\n            `);\n          }\n        });\n      };\n\n      await init();\n\n      const refresh = async () => {\n        let reset = false;\n        for (let i = 0; i < 5; i++) {\n          try {\n            await pg.transaction(async (tx) => {\n              // Populate the state table\n              await tx.exec(`\n                DELETE FROM live_query_${id}_state${stateSwitch};\n                INSERT INTO live_query_${id}_state${stateSwitch} \n                  SELECT * FROM live_query_${id}_view;\n              `);\n\n              // Get the changes\n              changes = await tx.query<any>(\n                `EXECUTE live_query_${id}_diff${stateSwitch};`,\n              );\n            });\n            break;\n          } catch (e) {\n            const msg = (e as Error).message;\n            if (\n              msg ==\n              `relation \"live_query_${id}_state${stateSwitch}\" does not exist`\n            ) {\n              // If the state table does not exist, reset and try again\n              // This can happen if using the multi-tab worker\n              reset = true;\n              await init();\n              continue;\n            } else {\n              throw e;\n            }\n          }\n        }\n\n        // Switch state\n        stateSwitch = stateSwitch === 1 ? 2 : 1;\n\n        callback([\n          ...(reset\n            ? [\n                {\n                  __op__: \"RESET\" as const,\n                },\n              ]\n            : []),\n          ...changes!.rows,\n        ]);\n      };\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = [];\n      for (const table of tables!) {\n        const unsub = await pg.listen(\n          `table_change__${table.schema_name}__${table.table_name}`,\n          async () => {\n            refresh();\n          },\n        );\n        unsubList.push(unsub);\n      }\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async () => {\n        for (const unsub of unsubList) {\n          await unsub();\n        }\n        await pg.exec(`\n          DROP VIEW IF EXISTS live_query_${id}_view;\n          DROP TABLE IF EXISTS live_query_${id}_state1;\n          DROP TABLE IF EXISTS live_query_${id}_state2;\n          DEALLOCATE live_query_${id}_diff1;\n          DEALLOCATE live_query_${id}_diff2;\n        `);\n      };\n\n      // Run the callback with the initial changes\n      await refresh();\n\n      // Fields\n      const fields = changes!.fields.filter(\n        (field) =>\n          ![\"__after__\", \"__op__\", \"__changed_columns__\"].includes(field.name),\n      );\n\n      // Return the initial results\n      return {\n        fields,\n        initialChanges: changes!.rows,\n        unsubscribe,\n        refresh,\n      } satisfies LiveChangesReturn<T>;\n    },\n\n    async incrementalQuery<T>(\n      query: string,\n      params: any[] | undefined | null,\n      key: string,\n      callback: (results: Results<Change<T>>) => void,\n    ) {\n      const rowsMap: Map<any, any> = new Map();\n      const afterMap: Map<any, any> = new Map();\n      let lastRows: Change<T>[] = [];\n      let firstRun = true;\n\n      const { fields, unsubscribe, refresh } = await namespaceObj.changes<T>(\n        query,\n        params,\n        key,\n        (changes) => {\n          // Process the changes\n          for (const change of changes) {\n            const {\n              __op__: op,\n              __changed_columns__: changedColumns,\n              ...obj\n            } = change as typeof change & { [key: string]: any };\n            switch (op) {\n              case \"RESET\":\n                rowsMap.clear();\n                afterMap.clear();\n                break;\n              case \"INSERT\":\n                rowsMap.set(obj[key], obj);\n                afterMap.set(obj.__after__, obj[key]);\n                break;\n              case \"DELETE\":\n                const oldObj = rowsMap.get(obj[key]);\n                rowsMap.delete(obj[key]);\n                afterMap.delete(oldObj.__after__);\n                break;\n              case \"UPDATE\":\n                const newObj = { ...(rowsMap.get(obj[key]) ?? {}) };\n                for (const columnName of changedColumns) {\n                  newObj[columnName] = obj[columnName];\n                  if (columnName === \"__after__\") {\n                    afterMap.set(obj.__after__, obj[key]);\n                  }\n                }\n                rowsMap.set(obj[key], newObj);\n                break;\n            }\n          }\n\n          // Get the rows in order\n          const rows: Change<T>[] = [];\n          let lastKey: any = null;\n          while (true) {\n            const nextKey = afterMap.get(lastKey);\n            const obj = rowsMap.get(nextKey);\n            if (!obj) {\n              break;\n            }\n            rows.push(obj);\n            lastKey = nextKey;\n          }\n          lastRows = rows;\n\n          // Run the callback\n          if (!firstRun) {\n            callback({\n              rows,\n              fields,\n            });\n          }\n        },\n      );\n\n      firstRun = false;\n      callback({\n        rows: lastRows,\n        fields,\n      });\n\n      return {\n        initialResults: {\n          rows: lastRows,\n          fields,\n        },\n        unsubscribe,\n        refresh,\n      } satisfies LiveQueryReturn<T>;\n    },\n  };\n\n  return {\n    namespaceObj,\n  };\n};\n\nexport const live = {\n  name: \"Live Queries\",\n  setup,\n} satisfies Extension;\n\n/**\n * Get a list of all the tables used in a view\n * @param tx a transaction or or PGlite instance\n * @param viewName the name of the view\n * @returns list of tables used in the view\n */\nasync function getTablesForView(\n  tx: Transaction | PGliteInterface,\n  viewName: string,\n): Promise<{ table_name: string; schema_name: string }[]> {\n  return (\n    await tx.query<{\n      table_name: string;\n      schema_name: string;\n    }>(\n      `\n        SELECT DISTINCT\n          cl.relname AS table_name,\n          n.nspname AS schema_name\n        FROM pg_rewrite r\n        JOIN pg_depend d ON r.oid = d.objid\n        JOIN pg_class cl ON d.refobjid = cl.oid\n        JOIN pg_namespace n ON cl.relnamespace = n.oid\n        WHERE\n        r.ev_class = (\n            SELECT oid FROM pg_class WHERE relname = $1 AND relkind = 'v'\n        )\n        AND d.deptype = 'n';\n      `,\n      [viewName],\n    )\n  ).rows.filter((row) => row.table_name !== viewName);\n}\n\n/**\n * Add triggers to tables to notify when they change\n * @param tx a transaction or PGlite instance\n * @param tables list of tables to add triggers to\n */\nasync function addNotifyTriggersToTables(\n  tx: Transaction | PGliteInterface,\n  tables: { table_name: string; schema_name: string }[],\n  tableNotifyTriggersAdded: Set<string>,\n) {\n  const triggers = tables\n    .filter(\n      (table) =>\n        !tableNotifyTriggersAdded.has(\n          `${table.schema_name}_${table.table_name}`,\n        ),\n    )\n    .map((table) => {\n      return `\n      CREATE OR REPLACE FUNCTION _notify_${table.schema_name}_${table.table_name}() RETURNS TRIGGER AS $$\n      BEGIN\n        PERFORM pg_notify('table_change__${table.schema_name}__${table.table_name}', '');\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n      CREATE OR REPLACE TRIGGER _notify_trigger_${table.schema_name}_${table.table_name}\n      AFTER INSERT OR UPDATE OR DELETE ON ${table.schema_name}.${table.table_name}\n      FOR EACH STATEMENT EXECUTE FUNCTION _notify_${table.schema_name}_${table.table_name}();\n      `;\n    })\n    .join(\"\\n\");\n  if (triggers.trim() !== \"\") {\n    await tx.exec(triggers);\n  }\n  tables.map((table) =>\n    tableNotifyTriggersAdded.add(`${table.schema_name}_${table.table_name}`),\n  );\n}\n","export const IN_NODE =\n  typeof process === \"object\" &&\n  typeof process.versions === \"object\" &&\n  typeof process.versions.node === \"string\";\n\nexport async function makeLocateFile() {\n  const PGWASM_URL = new URL(\"../release/postgres.wasm\", import.meta.url);\n  const PGSHARE_URL = new URL(\"../release/postgres.data\", import.meta.url);\n  let fileURLToPath = (fileUrl: URL) => fileUrl.pathname;\n  if (IN_NODE) {\n    fileURLToPath = (await import(\"url\")).fileURLToPath;\n  }\n  return (base: string) => {\n    let url: URL | null = null;\n    switch (base) {\n      case \"postgres.data\":\n        url = PGSHARE_URL;\n        break;\n      case \"postgres.wasm\":\n        url = PGWASM_URL;\n        break;\n      default:\n        console.error(\"makeLocateFile\", base);\n    }\n\n    if (url?.protocol === \"file:\") {\n      return fileURLToPath(url);\n    }\n    return url?.toString() ?? \"\";\n  };\n}\n\nexport const uuid = (): string => {\n  // best case, `crypto.randomUUID` is available\n  if (globalThis.crypto?.randomUUID) {\n    return globalThis.crypto.randomUUID();\n  }\n\n  const bytes = new Uint8Array(16);\n\n  if (globalThis.crypto?.getRandomValues) {\n    // `crypto.getRandomValues` is available even in non-secure contexts\n    globalThis.crypto.getRandomValues(bytes);\n  } else {\n    // fallback to Math.random, if the Crypto API is completely missing\n    for (let i = 0; i < bytes.length; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n\n  bytes[6] = (bytes[6] & 0x0f) | 0x40; // Set the 4 most significant bits to 0100\n  bytes[8] = (bytes[8] & 0x3f) | 0x80; // Set the 2 most significant bits to 10\n\n  const hexValues: string[] = [];\n  bytes.forEach((byte) => {\n    hexValues.push(byte.toString(16).padStart(2, \"0\"));\n  });\n\n  return (\n    hexValues.slice(0, 4).join(\"\") +\n    \"-\" +\n    hexValues.slice(4, 6).join(\"\") +\n    \"-\" +\n    hexValues.slice(6, 8).join(\"\") +\n    \"-\" +\n    hexValues.slice(8, 10).join(\"\") +\n    \"-\" +\n    hexValues.slice(10).join(\"\")\n  );\n};\n"],"mappings":"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","names":["live_exports","__export","live","__toCommonJS","IN_NODE","uuid","bytes","i","hexValues","byte","MAX_RETRIES","setup","pg","emscriptenOpts","tableNotifyTriggersAdded","namespaceObj","query","params","callback","id","uuid","results","tables","init","tx","getTablesForView","addNotifyTriggersToTables","refresh","count","e","unsubList","table","unsub","unsubscribe","key","stateSwitch","changes","columns","curr","prev","column_name","data_type","udt_name","reset","i","field","rowsMap","afterMap","lastRows","firstRun","fields","change","op","changedColumns","obj","oldObj","newObj","columnName","rows","lastKey","nextKey","live","viewName","row","triggers"]}