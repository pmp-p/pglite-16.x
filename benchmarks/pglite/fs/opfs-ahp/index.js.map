{"version":3,"sources":["../../../src/fs/opfs-ahp/index.ts","../../../src/fs/opfs-ahp/emscriptenFs.ts","../../../src/fs/opfs-ahp/types.ts","../../../src/fs/opfs-ahp/opfsAhp.ts"],"sourcesContent":["import { FilesystemBase } from \"../types.js\";\nimport { PGDATA } from \"../index.js\";\nimport type { PostgresMod, FS } from \"../../postgresMod.js\";\nimport { createOPFSAHP } from \"./emscriptenFs.js\";\nimport { OpfsAhp } from \"./opfsAhp.js\";\nimport { dumpTar } from \"../tarUtils.js\";\n\nexport interface OpfsAhpFSOptions {\n  initialPoolSize?: number;\n  maintainedPoolSize?: number;\n}\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends FilesystemBase {\n  #initialPoolSize: number;\n  #maintainedPoolSize: number;\n  opfsAhp?: OpfsAhp;\n\n  constructor(\n    dataDir: string,\n    { initialPoolSize, maintainedPoolSize }: OpfsAhpFSOptions = {},\n  ) {\n    super(dataDir);\n    this.#initialPoolSize = initialPoolSize ?? 1000;\n    this.#maintainedPoolSize = maintainedPoolSize ?? 100;\n  }\n\n  async emscriptenOpts(opts: Partial<PostgresMod>) {\n    this.opfsAhp = await OpfsAhp.create({\n      root: this.dataDir!,\n      initialPoolSize: this.#initialPoolSize,\n      maintainedPoolSize: this.#maintainedPoolSize,\n    });\n    const options: Partial<PostgresMod> = {\n      ...opts,\n      preRun: [\n        ...(opts.preRun || []),\n        (mod: PostgresMod) => {\n          const OPFS = createOPFSAHP(mod, this.opfsAhp!);\n          mod.FS.mkdir(PGDATA);\n          mod.FS.mount(OPFS, {}, PGDATA);\n        },\n      ],\n    };\n    return options;\n  }\n\n  async syncToFs(fs: FS, relaxedDurability = false) {\n    await this.opfsAhp?.maybeCheckpointState();\n    await this.opfsAhp?.maintainPool();\n    // console.log(\"syncToFs\", relaxedDurability);\n    if (!relaxedDurability) {\n      this.opfsAhp?.flush();\n    }\n  }\n\n  async dumpTar(mod: FS, dbname: string) {\n    return dumpTar(mod, dbname);\n  }\n\n  async close(FS: FS): Promise<void> {\n    this.opfsAhp?.exit();\n    FS.quit();\n  }\n}\n","import type { PostgresMod } from \"../../postgresMod.js\";\nimport type { OpfsAhp } from \"./opfsAhp.js\";\nimport { FsError, ERRNO_CODES } from \"./types.js\";\n\nexport type FileSystemType = Emscripten.FileSystemType & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode;\n  node_ops: FS.NodeOps;\n  stream_ops: FS.StreamOps & {\n    dup: (stream: FSStream) => void;\n    mmap: (\n      stream: FSStream,\n      length: number,\n      position: number,\n      prot: any,\n      flags: any,\n    ) => { ptr: number; allocated: boolean };\n    msync: (\n      stream: FSStream,\n      buffer: Uint8Array,\n      offset: number,\n      length: number,\n      mmapFlags: any,\n    ) => number;\n  };\n} & { [key: string]: any };\n\ntype FSNode = FS.FSNode & {\n  node_ops: FS.NodeOps;\n  stream_ops: FS.StreamOps;\n};\n\ntype FSStream = FS.FSStream & {\n  node: FSNode;\n  shared: {\n    refcount: number;\n  };\n};\n\nexport interface OpfsMount extends FS.Mount {\n  opts: {\n    root: string;\n  };\n}\n\ntype OpfsNode = FSNode & {};\n\ntype EmscriptenFS = PostgresMod[\"FS\"] & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode;\n};\n\n/**\n * Create an emscripten filesystem that uses the AHP filesystem.\n * @param Module The emscripten module\n * @param opfsAhp The AHP filesystem - see `OpfsAhp.ts`\n * @returns The emscripten filesystem\n */\nexport const createOPFSAHP = (Module: PostgresMod, opfsAhp: OpfsAhp) => {\n  const FS = Module.FS as EmscriptenFS;\n  const OPFS = {\n    tryFSOperation<T>(f: () => T): T {\n      try {\n        return f();\n      } catch (e: any) {\n        if (!e.code) throw e;\n        if (e.code === \"UNKNOWN\") throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        throw new FS.ErrnoError(e.code);\n      }\n    },\n    mount(mount: OpfsMount): FSNode {\n      return OPFS.createNode(null, \"/\", 16384 | 511, 0);\n    },\n    syncfs(\n      mount: FS.Mount,\n      populate: any, // This has the wrong type in @types/emscripten\n      done: (err?: number | null) => unknown,\n    ): void {\n      // noop\n    },\n    createNode(\n      parent: FSNode | null,\n      name: string,\n      mode: number,\n      dev?: any,\n    ): OpfsNode {\n      if (!FS.isDir(mode) && !FS.isFile(mode)) {\n        throw new FS.ErrnoError(28);\n      }\n      const node = FS.createNode(parent, name, mode);\n      node.node_ops = OPFS.node_ops;\n      node.stream_ops = OPFS.stream_ops;\n      return node;\n    },\n    getMode: function (path: string): number {\n      log(\"getMode\", path);\n      return OPFS.tryFSOperation(() => {\n        const stats = opfsAhp.lstat(path);\n        return stats.mode;\n      });\n    },\n    realPath: function (node: FSNode): string {\n      const parts = [];\n      while (node.parent !== node) {\n        parts.push(node.name);\n        node = node.parent as FSNode;\n      }\n      parts.push((node.mount as OpfsMount).opts.root);\n      parts.reverse();\n      return parts.join(\"/\");\n    },\n    node_ops: {\n      getattr(node: OpfsNode): FS.Stats {\n        log(\"getattr\", OPFS.realPath(node));\n        const path = OPFS.realPath(node);\n        return OPFS.tryFSOperation(() => {\n          const stats = opfsAhp.lstat(path);\n          return {\n            ...stats,\n            dev: 0,\n            ino: node.id,\n            nlink: 1,\n            rdev: node.rdev,\n            atime: new Date(stats.atime),\n            mtime: new Date(stats.mtime),\n            ctime: new Date(stats.ctime),\n          };\n        });\n      },\n      setattr(node: OpfsNode, attr: FS.Stats): void {\n        log(\"setattr\", OPFS.realPath(node), attr);\n        var path = OPFS.realPath(node);\n        OPFS.tryFSOperation(() => {\n          if (attr.mode !== undefined) {\n            opfsAhp.chmod(path, attr.mode);\n          }\n          if (attr.size !== undefined) {\n            opfsAhp.truncate(path, attr.size);\n          }\n          if (attr.timestamp !== undefined) {\n            opfsAhp.utimes(path, attr.timestamp, attr.timestamp);\n          }\n          if (attr.size !== undefined) {\n            opfsAhp.truncate(path, attr.size);\n          }\n        });\n      },\n      lookup(parent: FSNode, name: string): OpfsNode {\n        log(\"lookup\", OPFS.realPath(parent), name);\n        const path = [OPFS.realPath(parent), name].join(\"/\");\n        const mode = OPFS.getMode(path);\n        return OPFS.createNode(parent, name, mode);\n      },\n      mknod(\n        parent: FSNode,\n        name: string,\n        mode: number,\n        dev: unknown,\n      ): OpfsNode {\n        log(\"mknod\", OPFS.realPath(parent), name, mode, dev);\n        const node = OPFS.createNode(parent, name, mode, dev);\n        // create the backing node for this in the fs root as well\n        const path = OPFS.realPath(node);\n        return OPFS.tryFSOperation(() => {\n          if (FS.isDir(node.mode)) {\n            opfsAhp.mkdir(path, { mode });\n          } else {\n            opfsAhp.writeFile(path, \"\", { mode });\n          }\n          return node;\n        });\n      },\n      rename(oldNode: OpfsNode, newDir: OpfsNode, newName: string): void {\n        log(\"rename\", OPFS.realPath(oldNode), OPFS.realPath(newDir), newName);\n        const oldPath = OPFS.realPath(oldNode);\n        const newPath = [OPFS.realPath(newDir), newName].join(\"/\");\n        OPFS.tryFSOperation(() => {\n          opfsAhp.rename(oldPath, newPath);\n        });\n        oldNode.name = newName;\n      },\n      unlink(parent: OpfsNode, name: string): void {\n        log(\"unlink\", OPFS.realPath(parent), name);\n        const path = [OPFS.realPath(parent), name].join(\"/\");\n        try {\n          opfsAhp.unlink(path);\n        } catch (e: any) {}\n      },\n      rmdir(parent: OpfsNode, name: string): void {\n        log(\"rmdir\", OPFS.realPath(parent), name);\n        const path = [OPFS.realPath(parent), name].join(\"/\");\n        return OPFS.tryFSOperation(() => {\n          opfsAhp.rmdir(path);\n        });\n      },\n      readdir(node: OpfsNode): string[] {\n        log(\"readdir\", OPFS.realPath(node));\n        const path = OPFS.realPath(node);\n        return OPFS.tryFSOperation(() => {\n          return opfsAhp.readdir(path);\n        });\n      },\n      symlink(parent: FSNode, newName: string, oldPath: string): void {\n        log(\"symlink\", OPFS.realPath(parent), newName, oldPath);\n        // This is not supported by OPFS\n        throw new FS.ErrnoError(63);\n      },\n      readlink(node: FSNode): string {\n        log(\"readlink\", OPFS.realPath(node));\n        // This is not supported by OPFS\n        throw new FS.ErrnoError(63);\n      },\n    },\n    stream_ops: {\n      open(stream: FSStream): void {\n        log(\"open stream\", OPFS.realPath(stream.node));\n        const path = OPFS.realPath(stream.node);\n        return OPFS.tryFSOperation(() => {\n          if (FS.isFile(stream.node.mode)) {\n            stream.shared.refcount = 1;\n            stream.nfd = opfsAhp.open(path);\n          }\n        });\n      },\n      close(stream: FSStream): void {\n        log(\"close stream\", OPFS.realPath(stream.node));\n        return OPFS.tryFSOperation(() => {\n          if (\n            FS.isFile(stream.node.mode) &&\n            stream.nfd &&\n            --stream.shared.refcount === 0\n          ) {\n            opfsAhp.close(stream.nfd);\n          }\n        });\n      },\n      dup(stream: FSStream) {\n        log(\"dup stream\", OPFS.realPath(stream.node));\n        stream.shared.refcount++;\n      },\n      read(\n        stream: FSStream, // Stream to read from\n        buffer: Uint8Array, // Buffer to read into - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing to\n        length: number, // Number of bytes to read\n        position: number, // Position in file to read from\n      ): number {\n        log(\n          \"read stream\",\n          OPFS.realPath(stream.node),\n          offset,\n          length,\n          position,\n        );\n        if (length === 0) return 0;\n        const ret = OPFS.tryFSOperation(() =>\n          opfsAhp.read(\n            stream.nfd!,\n            buffer as unknown as Int8Array,\n            offset,\n            length,\n            position,\n          ),\n        );\n        return ret;\n      },\n      write(\n        stream: FSStream, // Stream to write to\n        buffer: Uint8Array, // Buffer to read from - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing from\n        length: number, // Number of bytes to write\n        position: number, // Position in file to write to\n      ): number {\n        log(\n          \"write stream\",\n          OPFS.realPath(stream.node),\n          offset,\n          length,\n          position,\n        );\n        return OPFS.tryFSOperation(() =>\n          opfsAhp.write(\n            stream.nfd!,\n            buffer.buffer as unknown as Int8Array,\n            offset,\n            length,\n            position,\n          ),\n        );\n      },\n      llseek(stream: FSStream, offset: number, whence: number): number {\n        log(\"llseek stream\", OPFS.realPath(stream.node), offset, whence);\n        var position = offset;\n        if (whence === 1) {\n          position += stream.position;\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            OPFS.tryFSOperation(() => {\n              var stat = opfsAhp.fstat(stream.nfd!);\n              position += stat.size;\n            });\n          }\n        }\n        if (position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        return position;\n      },\n      mmap(\n        stream: FSStream,\n        length: number,\n        position: number,\n        prot: any,\n        flags: any,\n      ) {\n        log(\n          \"mmap stream\",\n          OPFS.realPath(stream.node),\n          length,\n          position,\n          prot,\n          flags,\n        );\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n        }\n\n        var ptr = (Module as any).mmapAlloc(length); // TODO: Fix type and check this is exported\n\n        OPFS.stream_ops.read(\n          stream,\n          Module.HEAP8 as unknown as Uint8Array,\n          ptr,\n          length,\n          position,\n        );\n        return { ptr, allocated: true };\n      },\n      msync(\n        stream: FSStream,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        mmapFlags: any,\n      ) {\n        log(\n          \"msync stream\",\n          OPFS.realPath(stream.node),\n          offset,\n          length,\n          mmapFlags,\n        );\n        OPFS.stream_ops.write(stream, buffer, 0, length, offset);\n        return 0;\n      },\n    },\n  } satisfies FileSystemType;\n  return OPFS;\n};\n\nfunction log(...args: any[]) {\n  // console.log(...args);\n}\n","export type FsStats = {\n  dev: number;\n  ino: number;\n  mode: number;\n  nlink: number;\n  uid: number;\n  gid: number;\n  rdev: number;\n  size: number;\n  blksize: number;\n  blocks: number;\n  atime: number;\n  mtime: number;\n  ctime: number;\n};\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void;\n  flush(): void;\n  getSize(): number;\n  read(buffer: ArrayBuffer, options: { at: number }): number;\n  truncate(newSize: number): void;\n  write(buffer: ArrayBuffer, options: { at: number }): number;\n}\n\nexport const ERRNO_CODES = {\n  EBADF: 8,\n  EBADFD: 127,\n  EEXIST: 20,\n  EINVAL: 28,\n  EISDIR: 31,\n  ENODEV: 43,\n  ENOENT: 44,\n  ENOTDIR: 54,\n  ENOTEMPTY: 55,\n} as const;\n\nexport class FsError extends Error {\n  code?: number;\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message);\n    if (typeof code === \"number\") {\n      this.code = code;\n    } else if (typeof code === \"string\") {\n      this.code = ERRNO_CODES[code];\n    }\n  }\n}\n\n// State\n\nexport interface State {\n  root: DirectoryNode;\n  pool: PoolFilenames;\n}\n\nexport type PoolFilenames = Array<string>;\n\n// WAL\n\nexport interface WALEntry {\n  opp: string;\n  args: any[];\n}\n\n// Node tree\n\nexport type NodeType = \"file\" | \"directory\";\n\ninterface BaseNode {\n  type: NodeType;\n  lastModified: number;\n  mode: number;\n}\n\nexport interface FileNode extends BaseNode {\n  type: \"file\";\n  backingFilename: string;\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: \"directory\";\n  children: { [filename: string]: Node };\n}\n\nexport type Node = FileNode | DirectoryNode;\n","import { FsError } from \"./types.js\";\nimport type {\n  FsStats,\n  State,\n  FileSystemSyncAccessHandle,\n  Node,\n  FileNode,\n  DirectoryNode,\n  WALEntry,\n} from \"./types.js\";\n\nconst STATE_FILE = \"state.txt\";\nconst DATA_DIR = \"data\";\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n};\n\nexport interface OpfsAhpOptions {\n  root: string;\n  initialPoolSize?: number;\n  maintainedPoolSize?: number;\n}\n\n/**\n * An OPFS Access Handle Pool VFS that exports a Node.js-like FS interface.\n * This FS is then wrapped by an Emscripten FS interface in emscriptenFs.ts.\n */\nexport class OpfsAhp {\n  readyPromise: Promise<void>;\n  #ready = false;\n\n  readonly root: string;\n  readonly initialPoolSize: number;\n  readonly maintainedPoolSize: number;\n\n  #opfsRootAh!: FileSystemDirectoryHandle;\n  #rootAh!: FileSystemDirectoryHandle;\n  #dataDirAh!: FileSystemDirectoryHandle;\n\n  #stateFH!: FileSystemFileHandle;\n  #stateSH!: FileSystemSyncAccessHandle;\n\n  #fh: Map<string, FileSystemFileHandle> = new Map();\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map();\n\n  #handleIdCounter = 0;\n  #openHandlePaths: Map<number, string> = new Map();\n  #openHandleIds: Map<string, number> = new Map();\n\n  state!: State;\n  lastCheckpoint = 0;\n  checkpointInterval = 1000 * 60; // 1 minute\n  poolCounter = 0;\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>();\n\n  constructor({ root, initialPoolSize, maintainedPoolSize }: OpfsAhpOptions) {\n    this.root = root;\n    this.initialPoolSize = initialPoolSize || 1000;\n    this.maintainedPoolSize = maintainedPoolSize || 100;\n    this.readyPromise = this.#init();\n  }\n\n  static async create(options: OpfsAhpOptions) {\n    const instance = new OpfsAhp(options);\n    await instance.readyPromise;\n    return instance;\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory();\n    this.#rootAh = await this.#resolveOpfsDirectory(this.root, {\n      create: true,\n    });\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    });\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    });\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle();\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize());\n    this.#stateSH.read(stateAB, { at: 0 });\n    let state: State;\n    const stateLines = new TextDecoder().decode(stateAB).split(\"\\n\");\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false;\n    try {\n      state = JSON.parse(stateLines[0]);\n    } catch (e) {\n      state = {\n        root: {\n          type: \"directory\",\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      };\n      // write new state to file\n      this.#stateSH.truncate(0);\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      });\n      isNewState = true;\n    }\n    this.state = state;\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line));\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`;\n      if (typeof this[methodName as keyof this] === \"function\") {\n        try {\n          (this[methodName as keyof this] as any)(...entry.args);\n        } catch (e) {\n          console.warn(\"Error applying OPFS AHP WAL entry\", entry, e);\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = [];\n    const walk = async (node: Node) => {\n      if (node.type === \"file\") {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename);\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle();\n          this.#fh.set(node.backingFilename, fh);\n\n          this.#sh.set(node.backingFilename, sh);\n        } catch (e) {\n          console.error(\"Error opening file handle for node\", node, e);\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child));\n        }\n      }\n    };\n    await walk(this.state.root);\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = [];\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn(\"File handle already exists for pool file\", filename);\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename);\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle();\n          this.#fh.set(filename, fh);\n          this.#sh.set(filename, sh);\n          resolve();\n        }),\n      );\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises]);\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    );\n\n    this.#ready = true;\n  }\n\n  get ready() {\n    return this.#ready;\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize;\n    const change = size - this.state.pool.length;\n    const promises: Promise<void>[] = [];\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter;\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, \"0\")}-${this.poolCounter.toString(16).padStart(8, \"0\")}`;\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          });\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle();\n          this.#fh.set(filename, fh);\n          this.#sh.set(filename, sh);\n          this.#logWAL({\n            opp: \"createPoolFile\",\n            args: [filename],\n          });\n          this.state.pool.push(filename);\n          resolve();\n        }),\n      );\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!;\n          this.#logWAL({\n            opp: \"deletePoolFile\",\n            args: [filename],\n          });\n          const fh = this.#fh.get(filename)!;\n          const sh = this.#sh.get(filename);\n          sh?.close();\n          // @ts-ignore\n          await fh.remove();\n          this.#fh.delete(filename);\n          this.#sh.delete(filename);\n          resolve();\n        }),\n      );\n    }\n    await Promise.all(promises);\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename);\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename);\n    if (index > -1) {\n      this.state.pool.splice(index, 1);\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState();\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state));\n    this.#stateSH.truncate(0);\n    this.#stateSH.write(stateAB, { at: 0 });\n    this.#stateSH.flush();\n    this.lastCheckpoint = Date.now();\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush();\n      } catch (e) {} // The file may have been closed if it was deleted\n    }\n    this.#unsyncedSH.clear();\n  }\n\n  exit(): void {\n    for (const sh of this.#sh.values()) {\n      sh.close();\n    }\n    this.#stateSH.flush();\n    this.#stateSH.close();\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: \"chmod\", args: [path, mode] }, () => {\n      this._chmodState(path, mode);\n    });\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path);\n    node.mode = mode;\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd);\n    this.#openHandlePaths.delete(fd);\n    this.#openHandleIds.delete(path);\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd);\n    return this.lstat(path);\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path);\n    const size =\n      node.type === \"file\" ? this.#sh.get(node.backingFilename)!.getSize() : 0;\n    const blksize = 4096;\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    };\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: \"mkdir\", args: [path, options] }, () => {\n      this._mkdirState(path, options);\n    });\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path);\n    const newDirName = parts.pop()!;\n    let currentPath = [];\n    let node = this.state.root;\n    for (const part of parts) {\n      currentPath.push(path);\n      if (!node.children.hasOwnProperty(part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join(\"/\"));\n        } else {\n          throw new FsError(\"ENOENT\", \"No such file or directory\");\n        }\n      }\n      if (node.children[part].type !== \"directory\") {\n        throw new FsError(\"ENOTDIR\", \"Not a directory\");\n      }\n      node = node.children[part] as DirectoryNode;\n    }\n    if (node.children.hasOwnProperty(newDirName)) {\n      throw new FsError(\"EEXIST\", \"File exists\");\n    }\n    const newDir: DirectoryNode = {\n      type: \"directory\",\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    };\n    node.children[newDirName] = newDir;\n  }\n\n  open(path: string, flags?: string, mode?: number): number {\n    const node = this.#resolvePath(path);\n    if (node.type !== \"file\") {\n      throw new FsError(\"EISDIR\", \"Is a directory\");\n    }\n    const handleId = this.#nextHandleId();\n    this.#openHandlePaths.set(handleId, path);\n    this.#openHandleIds.set(path, handleId);\n    return handleId;\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path);\n    if (node.type !== \"directory\") {\n      throw new FsError(\"ENOTDIR\", \"Not a directory\");\n    }\n    return Object.keys(node.children);\n  }\n\n  read(\n    fd: number,\n    buffer: Int8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd);\n    const node = this.#resolvePath(path);\n    if (node.type !== \"file\") {\n      throw new FsError(\"EISDIR\", \"Is a directory\");\n    }\n    const sh = this.#sh.get(node.backingFilename)!;\n    return sh.read(new Int8Array(buffer.buffer, offset, length), {\n      at: position,\n    });\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: \"rename\", args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true);\n    });\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath);\n    const oldFilename = oldPathParts.pop()!;\n    const oldParent = this.#resolvePath(\n      oldPathParts.join(\"/\"),\n    ) as DirectoryNode;\n    if (!oldParent.children.hasOwnProperty(oldFilename)) {\n      throw new FsError(\"ENOENT\", \"No such file or directory\");\n    }\n    const newPathParts = this.#pathParts(newPath);\n    const newFilename = newPathParts.pop()!;\n    const newParent = this.#resolvePath(\n      newPathParts.join(\"/\"),\n    ) as DirectoryNode;\n    if (doFileOps && newParent.children.hasOwnProperty(newFilename)) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode;\n      const sh = this.#sh.get(node.backingFilename)!;\n      sh.truncate(0);\n      this.state.pool.push(node.backingFilename);\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!;\n    delete oldParent.children[oldFilename];\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: \"rmdir\", args: [path] }, () => {\n      this._rmdirState(path);\n    });\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path);\n    const dirName = pathParts.pop()!;\n    const parent = this.#resolvePath(pathParts.join(\"/\")) as DirectoryNode;\n    if (!parent.children.hasOwnProperty(dirName)) {\n      throw new FsError(\"ENOENT\", \"No such file or directory\");\n    }\n    const node = parent.children[dirName]!;\n    if (node.type !== \"directory\") {\n      throw new FsError(\"ENOTDIR\", \"Not a directory\");\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError(\"ENOTEMPTY\", \"Directory not empty\");\n    }\n    delete parent.children[dirName];\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path);\n    if (node.type !== \"file\") {\n      throw new FsError(\"EISDIR\", \"Is a directory\");\n    }\n    const sh = this.#sh.get(node.backingFilename);\n    if (!sh) {\n      throw new FsError(\"ENOENT\", \"No such file or directory\");\n    }\n    sh.truncate(len);\n    this.#unsyncedSH.add(sh);\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: \"unlink\", args: [path] }, () => {\n      this._unlinkState(path, true);\n    });\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path);\n    const filename = pathParts.pop()!;\n    const dir = this.#resolvePath(pathParts.join(\"/\")) as DirectoryNode;\n    if (!dir.children.hasOwnProperty(filename)) {\n      throw new FsError(\"ENOENT\", \"No such file or directory\");\n    }\n    const node = dir.children[filename]!;\n    if (node.type !== \"file\") {\n      throw new FsError(\"EISDIR\", \"Is a directory\");\n    }\n    delete dir.children[filename];\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!;\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0);\n      this.#unsyncedSH.add(sh);\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!);\n        this.#openHandleIds.delete(path);\n      }\n    }\n    this.state.pool.push(node.backingFilename);\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: \"utimes\", args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime);\n    });\n  }\n\n  _utimesState(path: string, atime: number, mtime: number): void {\n    const node = this.#resolvePath(path);\n    node.lastModified = mtime;\n  }\n\n  writeFile(\n    path: string,\n    data: string | Int8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path);\n    const filename = pathParts.pop()!;\n    const parent = this.#resolvePath(pathParts.join(\"/\")) as DirectoryNode;\n\n    if (!parent.children.hasOwnProperty(filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error(\"No more file handles available in the pool\");\n      }\n      const node: Node = {\n        type: \"file\",\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      };\n      parent.children[filename] = node;\n      this.#logWAL({\n        opp: \"createFileNode\",\n        args: [path, node],\n      });\n    } else {\n      const node = parent.children[filename] as FileNode;\n      node.lastModified = Date.now();\n      this.#logWAL({\n        opp: \"setLastModified\",\n        args: [path, node.lastModified],\n      });\n    }\n    const node = parent.children[filename] as FileNode;\n    const sh = this.#sh.get(node.backingFilename)!;\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === \"string\"\n          ? new TextEncoder().encode(data)\n          : new Int8Array(data),\n        { at: 0 },\n      );\n      if (path.startsWith(\"/pg_wal\")) {\n        this.#unsyncedSH.add(sh);\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path);\n    const filename = pathParts.pop()!;\n    const parent = this.#resolvePath(pathParts.join(\"/\")) as DirectoryNode;\n    parent.children[filename] = node;\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename);\n    if (index > -1) {\n      this.state.pool.splice(index, 1);\n    }\n    return node;\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path);\n    node.lastModified = lastModified;\n  }\n\n  write(\n    fd: number,\n    buffer: Int8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd);\n    const node = this.#resolvePath(path);\n    if (node.type !== \"file\") {\n      throw new FsError(\"EISDIR\", \"Is a directory\");\n    }\n    const sh = this.#sh.get(node.backingFilename);\n    if (!sh) {\n      throw new FsError(\"EBADF\", \"Bad file descriptor\");\n    }\n    const ret = sh.write(new Int8Array(buffer, offset, length), {\n      at: position,\n    });\n    if (path.startsWith(\"/pg_wal\")) {\n      this.#unsyncedSH.add(sh);\n    }\n    return ret;\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry);\n    try {\n      fn();\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset);\n      throw e;\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry);\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`);\n    const offset = this.#stateSH.getSize();\n    this.#stateSH.write(stateAB, { at: offset });\n    this.#unsyncedSH.add(this.#stateSH);\n    return offset;\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split(\"/\").filter(Boolean);\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path);\n    let node: Node = from || this.state.root;\n    for (const part of parts) {\n      if (node.type !== \"directory\") {\n        throw new FsError(\"ENOTDIR\", \"Not a directory\");\n      }\n      if (!node.children.hasOwnProperty(part)) {\n        throw new FsError(\"ENOENT\", \"No such file or directory\");\n      }\n      node = node.children[part]!;\n    }\n    return node;\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd);\n    if (!path) {\n      throw new FsError(\"EBADF\", \"Bad file descriptor\");\n    }\n    return path;\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter;\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++;\n    }\n    return id;\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle;\n      create?: boolean;\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path);\n    let ah = options?.from || this.#opfsRootAh;\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create });\n    }\n    return ah;\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","init_esm_shims","init_esm_shims","ERRNO_CODES","FsError","code","message","createOPFSAHP","Module","opfsAhp","FS","OPFS","f","e","ERRNO_CODES","mount","populate","done","parent","name","mode","dev","node","path","log","parts","stats","attr","oldNode","newDir","newName","oldPath","newPath","stream","buffer","offset","length","position","whence","stat","prot","flags","ptr","mmapFlags","args","init_esm_shims","STATE_FILE","DATA_DIR","INITIAL_MODE","_ready","_opfsRootAh","_rootAh","_dataDirAh","_stateFH","_stateSH","_fh","_sh","_handleIdCounter","_openHandlePaths","_openHandleIds","_unsyncedSH","_OpfsAhp_instances","init_fn","tryWithWAL_fn","logWAL_fn","pathParts_fn","resolvePath_fn","getPathFromFd_fn","nextHandleId_fn","resolveOpfsDirectory_fn","_OpfsAhp","root","initialPoolSize","maintainedPoolSize","__privateAdd","__privateMethod","options","instance","__privateGet","size","change","promises","i","resolve","filename","fh","sh","index","stateAB","path","mode","node","fd","blksize","parts","newDirName","currentPath","part","FsError","newDir","flags","handleId","buffer","offset","length","position","oldPath","newPath","doFileOps","oldPathParts","oldFilename","oldParent","newPathParts","newFilename","newParent","pathParts","dirName","parent","len","dir","atime","mtime","data","lastModified","ret","__privateSet","state","stateLines","isNewState","wal","line","entry","methodName","e","walkPromises","walk","child","poolPromises","fn","entryJSON","from","id","__privateWrapper","ah","OpfsAhp","_initialPoolSize","_maintainedPoolSize","OpfsAhpFS","FilesystemBase","dataDir","initialPoolSize","maintainedPoolSize","__privateAdd","__privateSet","opts","OpfsAhp","__privateGet","mod","OPFS","createOPFSAHP","PGDATA","fs","relaxedDurability","dbname","dumpTar","FS"]}